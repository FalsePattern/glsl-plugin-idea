<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glsl Builtin Functions</title>
</head>
<body>
<div id=abs><div></div><div><h2>Name</h2><p>abs — return the absolute value of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType abs(genType x);</code></table></div><div><table><tr><td><code>genIType abs(genIType x);</code></table></div><div><table><tr><td><code>genDType abs(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of which to return the absolute.</dt></dl></div></div><div><h2>Description</h2><p><code>abs</code> returns the absolute value of <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>abs (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>abs (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>abs (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sign><span><span>sign</span></span></a></div></div>
<div id=acos><div></div><div><h2>Name</h2><p>acos — return the arccosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType acos(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose arccosine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>acos</code> returns the angle whose trigonometric cosine is $x$. The range of values returned by <code>acos</code> is $[0,\pi]$. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>acos<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#asin><span><span>asin</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=acosh><div></div><div><h2>Name</h2><p>acosh — return the arc hyperbolic cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType acosh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose arc hyperbolic cosine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>acosh</code> returns the arc hyperbolic cosine of $x$; the non-negative inverse of <a href=#cosh><span><span>cosh</span></span></a>. The result is undefined if $x < 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>acosh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=all><div></div><div><h2>Name</h2><p>all — check whether all elements of a boolean vector are true</div><div><h2>Declaration</h2><div><table><tr><td><code>bool all(bvec x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the vector to be tested for truth.</dt></dl></div></div><div><h2>Description</h2><p><code>all</code> returns true if all elements of <em><code>x</code></em> are true and false otherwise. It is functionally equivalent to:<p><pre>    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4
    {
        bool result = true;
        int i;
        for (i = 0; i < x.length(); ++i)
        {
            result &= x[i];
        }
        return result;
    }</pre><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>all<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#any><span><span>any</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=any><div></div><div><h2>Name</h2><p>any — check whether any element of a boolean vector is true</div><div><h2>Declaration</h2><div><table><tr><td><code>bool any(bvec x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the vector to be tested for truth.</dt></dl></div></div><div><h2>Description</h2><p><code>any</code> returns true if any element of <em><code>x</code></em> is true and false otherwise. It is functionally equivalent to:<p><pre>    bool any(bvec x) {     // bvec can be bvec2, bvec3 or bvec4
        bool result = false;
        int i;
        for (i = 0; i < x.length(); ++i) {
            result |= x[i];
        }
        return result;
    }</pre><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>any<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=asin><div></div><div><h2>Name</h2><p>asin — return the arcsine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType asin(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose arcsine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>asin</code> returns the angle whose trigonometric sine is $x$. The range of values returned by <code>asin</code> is $[-{\pi \over 2}, {\pi \over 2}]$. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>asin<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#acos><span><span>acos</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=asinh><div></div><div><h2>Name</h2><p>asinh — return the arc hyperbolic sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType asinh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose arc hyperbolic sine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>asinh</code> returns the arc hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>; the inverse of <a href=#sinh><span><span>sinh</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>asinh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=atan><div></div><div><h2>Name</h2><p>atan — return the arc-tangent of the parameters</div><div><h2>Declaration</h2><div><table><tr><td><code>genType atan(genType y, genType x);</code></table></div><div><table><tr><td><code>genType atan(genType y_over_x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>y</code> </em> </span> - Specify the numerator of the fraction whose arctangent to return.<dt><span> <em> <code>x</code> </em> </span> - Specify the denominator of the fraction whose arctangent to return.<dt><span> <em> <code>y_over_x</code> </em> </span> - Specify the fraction whose arctangent to return.</dt></dl></div></div><div><h2>Description</h2><p><code>atan</code> returns either the angle whose trigonometric arctangent is $y \over x$ or <em><code>y_over_x</code></em>, depending on which overload is invoked. In the first overload, the signs of $y$ and $x$ are used to determine the quadrant that the angle lies in. The value returned by <code>atan</code> in this case is in the range $[-\pi,\pi]$. The result is undefined if $x = 0$.<p>For the second overload, <code>atan</code> returns the angle whose tangent is <em><code>y_over_x</code></em>. The value returned in this case is in the range $[-{\pi \over 2 },{\pi \over 2}]$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atan<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=atanh><div></div><div><h2>Name</h2><p>atanh — return the arc hyperbolic tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType atanh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose arc hyperbolic tangent to return.</dt></dl></div></div><div><h2>Description</h2><p><code>atanh</code> returns the arc hyperbolic tangent of $x$; the inverse of <a href=#tanh><span><span>tanh</span></span></a>. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atanh<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=atomicAdd><div></div><div><h2>Name</h2><p>atomicAdd — perform an atomic addition to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicAdd(inout int mem, int data);</code></table><table><tr><td><code>uint atomicAdd(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be added to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicAdd</code> performs an atomic addition of <em><code>data</code></em> to the contents of <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the addition occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicAdd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicAnd><div></div><div><h2>Name</h2><p>atomicAnd — perform an atomic logical AND operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicAnd(inout int mem, int data);</code></table><table><tr><td><code>uint atomicAnd(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be logically ANDed with to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicAnd</code> performs an atomic logical AND with <em><code>data</code></em> to the contents of <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicAnd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicCompSwap><div></div><div><h2>Name</h2><p>atomicCompSwap — perform an atomic compare-exchange operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicCompSwap(inout int mem, uint compare, uint data);</code></table><table><tr><td><code>uint atomicCompSwap(inout uint mem, uint compare, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be compared and potentially exchanged with</dt></dl></div></div><div><h2>Description</h2><p><code>atomicCompSwap</code> performs an atomic comparison of <em><code>compare</code></em> with the contents of <em><code>mem</code></em>. If the content of <em><code>mem</code></em> is equal to <em><code>compare</code></em>, then the content of <em><code>data</code></em> is written into <em><code>mem</code></em>, otherwise the content of <em><code>mem</code></em> is unmodifed. The function returns the original content of <em><code>mem</code></em> regardless of the outcome of the comparison. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCompSwap<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a></div></div>
<div id=atomicCounter><div></div><div><h2>Name</h2><p>atomicCounter — return the current value of an atomic counter</div><div><h2>Declaration</h2><div><table><tr><td><code>uint atomicCounter(atomic_uint c);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>c</code> </em> </span> - Specify the handle to the atomic counter whose value to return.</dt></dl></div></div><div><h2>Description</h2><p><code>atomicCounter</code> returns the current value of the atomic counter <em><code>c</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounter<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterIncrement><span><span>atomicCounterIncrement</span></span></a>, <a href=#atomicCounterDecrement><span><span>atomicCounterDecrement</span></span></a></div></div>
<div id=atomicCounterDecrement><div></div><div><h2>Name</h2><p>atomicCounterDecrement — atomically decrement a counter and return the prior value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint atomicCounterDecrement(atomic_uint c);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>c</code> </em> </span> - Specify the handle to the atomic counter to decrement.</dt></dl></div></div><div><h2>Description</h2><p><code>atomicCounterDecrement</code> atomically decrements the value of the atomic counter <em><code>c</code></em> and returns its new value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounterDecrement<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterIncrement><span><span>atomicCounterIncrement</span></span></a>, <a href=#atomicCounter><span><span>atomicCounter</span></span></a></div></div>
<div id=atomicCounterIncrement><div></div><div><h2>Name</h2><p>atomicCounterIncrement — atomically increment a counter and return the prior value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint atomicCounterIncrement(atomic_uint c);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>c</code> </em> </span> - Specify the handle to the atomic counter to increment.</dt></dl></div></div><div><h2>Description</h2><p><code>atomicCounterIncrement</code> atomically increments the value of the atomic counter <em><code>c</code></em> and returns its prior value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounterIncrement<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterDecrement><span><span>atomicCounterDecrement</span></span></a>, <a href=#atomicCounter><span><span>atomicCounter</span></span></a></div></div>
<div id=atomicExchange><div></div><div><h2>Name</h2><p>atomicExchange — perform an atomic exchange operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicExchange(inout int mem, int data);</code></table><table><tr><td><code>uint atomicExchange(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be exchanged with</dt></dl></div></div><div><h2>Description</h2><p><code>atomicExchange</code> performs an atomic exhange of <em><code>data</code></em> with the contents of <em><code>mem</code></em>. The content of <em><code>data</code></em> is written into <em><code>mem</code></em> and the original contents of <em><code>mem</code></em> are returned. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicExchange<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicMax><div></div><div><h2>Name</h2><p>atomicMax — perform an atomic max operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicMax(inout int mem, int data);</code></table><table><tr><td><code>uint atomicMax(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be compared to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicMax</code> performs an atomic comparison of <em><code>data</code></em> to the contents of <em><code>mem</code></em>, writes the maximum value into <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicMax<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicMin><div></div><div><h2>Name</h2><p>atomicMin — perform an atomic min operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicMin(inout int mem, int data);</code></table><table><tr><td><code>uint atomicMin(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be compared to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicMin</code> performs an atomic comparison of <em><code>data</code></em> to the contents of <em><code>mem</code></em>, writes the minimum value into <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicMin<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicOr><div></div><div><h2>Name</h2><p>atomicOr — perform an atomic logical OR operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicOr(inout int mem, int data);</code></table><table><tr><td><code>uint atomicOr(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be logically ORed with to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicOr</code> performs an atomic logical OR with <em><code>data</code></em> to the contents of <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicOr<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicXor><div></div><div><h2>Name</h2><p>atomicXor — perform an atomic logical exclusive OR operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td><code>int atomicXor(inout int mem, int data);</code></table><table><tr><td><code>uint atomicXor(inout uint mem, uint data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>mem</code> </em> </span> - The variable to use as the target of the operation.<dt><span> <em> <code>data</code> </em> </span> - The data to be logically exclusive ORed with to</dt></dl></div></div><div><h2>Description</h2><p><code>atomicXor</code> performs an atomic logical exclusive OR with <em><code>data</code></em> to the contents of <em><code>mem</code></em> and returns the original contents of <em><code>mem</code></em> from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicXor<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=bitCount><div></div><div><h2>Name</h2><p>bitCount — counts the number of 1 bits in an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType bitCount(genIType value);</code></table><table><tr><td><code>genIType bitCount(genUType value);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>value</code> </em> </span> - Specifies the value whose bits to count.</dt></dl></div></div><div><h2>Description</h2><p><code>bitCount</code> returns the number of bits that are set to 1 in the binary representation of <em><code>value</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitCount<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findLSB><span><span>findLSB</span></span></a>, <a href=#findMSB><span><span>findMSB</span></span></a></div></div>
<div id=bitfieldExtract><div></div><div><h2>Name</h2><p>bitfieldExtract — extract a range of bits from an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType bitfieldExtract(genIType value, int offset, int bits);</code></table><table><tr><td><code>genUType bitfieldExtract(genUType value, int offset, int bits);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>value</code> </em> </span> - Specifies the integer from which to extract bits.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the index of the first bit to extract.<dt><span> <em> <code>bits</code> </em> </span> - Specifies the number of bits to extract.</dt></dl></div></div><div><h2>Description</h2><p><code>bitfieldExtract</code> extracts a subset of the bits of <em><code>value</code></em> and returns it in the least significant bits of the result. The range of bits extracted is [<em><code>offset</code></em>, <em><code>offset</code></em> + <em><code>bits</code></em> - 1].<p>For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit <em><code>offset</code></em> + <em><code>base</code></em> - 1 (i.e., it is <span><em>sign extended</em></span> to the width of the return type).<p>If <em><code>bits</code></em> is zero, the result will be zero. The result will be undefined if <em><code>offset</code></em> or <em><code>bits</code></em> is negative, or if the sum of <em><code>offset</code></em> and <em><code>bits</code></em> is greater than the number of bits used to store the operand.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldInsert<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a></div></div>
<div id=bitfieldInsert><div></div><div><h2>Name</h2><p>bitfieldInsert — insert a range of bits into an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType bitfieldInsert(genIType base, genIType insert, int offset, int bits);</code></table><table><tr><td><code>genUType bitfieldInsert(genUType base, genUType insert, int offset, int bits);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>base</code> </em> </span> - Specifies the integer into which to insert<dt><span> <em> <code>insert</code> </em> </span> - Specifies the value of the bits to insert.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the index of the first bit to insert.<dt><span> <em> <code>bits</code> </em> </span> - Specifies the number of bits to insert.</dt></dl></div></div><div><h2>Description</h2><p><code>bitfieldInsert</code> inserts the <em><code>bits</code></em> least significant bits of <em><code>insert</code></em> into <em><code>base</code></em> at offset <em><code>offset</code></em>. The returned value will have bits [<em><code>offset</code></em>, <em><code>offset</code></em> + <em><code>bits</code></em> + 1] taken from [0, <em><code>bits</code></em> - 1] of <em><code>insert</code></em> and all other bits taken directly from the corresponding bits of <em><code>base</code></em>. If <em><code>bits</code></em> is zero, the result will simply be the original value of <em><code>base</code></em>. The result will be undefined if <em><code>offset</code></em> or <em><code>bits</code></em> is negative, or if the sum of <em><code>offset</code></em> and <em><code>bits</code></em> is greater than the number of bits used to store the operand.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldInsert<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a></div></div>
<div id=bitfieldReverse><div></div><div><h2>Name</h2><p>bitfieldReverse — reverse the order of bits in an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType bitfieldReverse(genIType value);</code></table><table><tr><td><code>genUType bitfieldReverse(genUType value);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>value</code> </em> </span> - Specifies the value whose bits to reverse.</dt></dl></div></div><div><h2>Description</h2><p><code>bitfieldReverse</code> returns the reversal of the bits of value. The bit numbered <span><em>n</em></span> will be taken from bit (<span><em>bits</em></span> - 1) - <span><em>n</em></span> of <em><code>value</code></em>, where <span><em>bits</em></span> is the total number of bits used to represent <em><code>value</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldReverse<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a>, <a href=#bitfieldInsert><span><span>bitfieldInsert</span></span></a>, <a href=#bitCount><span><span>bitCount</span></span></a></div></div>
<div id=ceil><div></div><div><h2>Name</h2><p>ceil — find the nearest integer that is greater than or equal to the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType ceil(genType x);</code></table></div><div><table><tr><td><code>genDType ceil(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>ceil</code> returns a value equal to the nearest integer that is greater than or equal to <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>ceil (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>ceil (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=clamp><div></div><div><h2>Name</h2><p>clamp — constrain a value to lie between two further values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType clamp(genType x, genType minVal, genType maxVal);</code></table></div><div><table><tr><td><code>genType clamp(genType x, float minVal, float maxVal);</code></table></div><div><table><tr><td><code>genDType clamp(genDType x, genDType minVal, genDType maxVal);</code></table></div><div><table><tr><td><code>genDType clamp(genDType x, double minVal, double maxVal);</code></table></div><div><table><tr><td><code>genIType clamp(genIType x, genIType minVal, genIType maxVal);</code></table></div><div><table><tr><td><code>genIType clamp(genIType x, int minVal, int maxVal);</code></table></div><div><table><tr><td><code>genUType clamp(genUType x, genUType minVal, genUType maxVal);</code></table></div><div><table><tr><td><code>genUType clamp(genUType x, uint minVal, uint maxVal);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to constrain.<dt><span> <em> <code>minVal</code> </em> </span> - Specify the lower end of the range into which to constrain<dt><span> <em> <code>maxVal</code> </em> </span> - Specify the upper end of the range into which to constrain</dt></dl></div></div><div><h2>Description</h2><p><code>clamp</code> returns the value of <em><code>x</code></em> constrained to the range <em><code>minVal</code></em> to <em><code>maxVal</code></em>. The returned value is computed as <a href=#min><span><span>min</span></span></a>(<a href=#max><span><span>max</span></span></a>(<em><code>x</code></em>, <em><code>minVal</code></em>), <em><code>maxVal</code></em>).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>clamp (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#max><span><span>max</span></span></a></div></div>
<div id=cos><div></div><div><h2>Name</h2><p>cos — return the cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType cos(genType angle);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>angle</code> </em> </span> - Specify the quantity, in radians, of which to return the cosine.</dt></dl></div></div><div><h2>Description</h2><p><code>cos</code> returns the trigonometric cosine of <em><code>angle</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cos<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a></div></div>
<div id=cosh><div></div><div><h2>Name</h2><p>cosh — return the hyperbolic cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType cosh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose hyperbolic cosine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>cosh</code> returns the hyperbolic cosine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic cosine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:msup> <mml:mi>e</mml:mi> <mml:mi>x</mml:mi> </mml:msup> <mml:mo>+</mml:mo> <mml:msup> <mml:mi>e</mml:mi> <mml:mrow> <mml:mo>−</mml:mo> <mml:mi>x</mml:mi> </mml:mrow> </mml:msup> </mml:mrow> <mml:mn>2</mml:mn> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cosh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a></div></div>
<div id=cross><div></div><div><h2>Name</h2><p>cross — calculate the cross product of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>vec3 cross(vec3 x, vec3 y);</code></table><table><tr><td><code>dvec3 cross(dvec3 x, dvec3 y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first of two vectors<dt><span> <em> <code>y</code> </em> </span> - Specifies the second of two vectors</dt></dl></div></div><div><h2>Description</h2><p><code>cross</code> returns the cross product of two vectors, <em><code>x</code></em> and <em><code>y</code></em>, i.e. $\begin{pmatrix} { x[1] \times y[2] - y[1] \times x[2] } \\ { x[2] \times y[0] - y[2] \times x[0] } \\ { x[0] \times y[1] - y[0] \times x[1] } \end{pmatrix}$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cross (vec3)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>cross (dvec3)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a></div></div>
<div id=degrees><div></div><div><h2>Name</h2><p>degrees — convert a quantity in radians to degrees</div><div><h2>Declaration</h2><div><table><tr><td><code>genType degrees(genType radians);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>radians</code> </em> </span> - Specify the quantity, in radians, to be converted to degrees.</dt></dl></div></div><div><h2>Description</h2><p><code>degrees</code> converts a quantity specified in radians into degrees. The return value is ${ 180 \times radians } \over \pi$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>degrees<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#radians><span><span>radians</span></span></a></div></div>
<div id=determinant><div></div><div><h2>Name</h2><p>determinant — calculate the determinant of a matrix</div><div><h2>Declaration</h2><div><table><tr><td><code>float determinant(mat2 m);</code></table><table><tr><td><code>float determinant(mat3 m);</code></table><table><tr><td><code>float determinant(mat4 m);</code></table><table><tr><td><code>double determinant(dmat2 m);</code></table><table><tr><td><code>double determinant(dmat3 m);</code></table><table><tr><td><code>double determinant(dmat4 m);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>m</code> </em> </span> - Specifies the matrix of which to take the determinant.</dt></dl></div></div><div><h2>Description</h2><p><code>determinant</code> returns the determinant of the matrix <em><code>m</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>determinant (float)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>determinant (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#transpose><span><span>transpose</span></span></a>, <a href=#inverse><span><span>inverse</span></span></a></div></div>
<div id=dFdx><div></div><div><h2>Name</h2><p>dFdx, dFdy — return the partial derivative of an argument with respect to x or y</div><div><h2>Declaration</h2><div><table><tr><td><code>genType dFdx(genType p);</code></table><table><tr><td><code>genType dFdy(genType p);</code></table><table><tr><td><code>genType dFdxCoarse(genType p);</code></table><table><tr><td><code>genType dFdyCoarse(genType p);</code></table><table><tr><td><code>genType dFdxFine(genType p);</code></table><table><tr><td><code>genType dFdyFine(genType p);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>p</code> </em> </span> - Specifies the expression of which to take the partial derivative.</dt></dl></div></div><div><h2>Description</h2><p><span><em>Available only in the fragment shader</em></span>, these functions return the partial derivative of expression <em><code>p</code></em> with respect to the window $x$ coordinate (for <code>dFdx*</code>) and $y$ coordinate (for <code>dFdy*</code>).<p><code>dFdxFine</code> and <code>dFdyFine</code> calculate derivatives using local differencing based on the value of <em><code>p</code></em> for the current fragment and its immediate neighbor(s).<p><code>dFdxCoarse</code> and <code>dFdyCoarse</code> calculate derivatives using local differencing based on the value of <em><code>p</code></em> for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding <code>dFdxFine</code> and <code>dFdyFine</code> functions.<p><code>dFdx</code> returns either <code>dFdxCoarse</code> or <code>dFdxFine</code>. <code>dFdy</code> returns either <code>dFdyCoarse</code> or <code>dFdyFine</code>. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API <code>GL_FRAGMENT_SHADER_DERIVATIVE_HINT</code> hint.<p>Expressions that imply higher order derivatives such as <code>dFdx(dFdx(n))</code> have undefined results, as do mixed-order derivatives such as <code>dFdx(dFdy(n))</code>. It is assumed that the expression <em><code>p</code></em> is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>dFdx<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dFdy<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dFdxCoarse, dFdxFine, dFdyCoarse, dFdyFine<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#fwidth><span><span>fwidth</span></span></a>, <a href=#glHint><span><span>glHint</span></span></a></div></div>
<div id=distance><div></div><div><h2>Name</h2><p>distance — calculate the distance between two points</div><div><h2>Declaration</h2><div><table><tr><td><code>float distance(genType p0, genType p1);</code></table><table><tr><td><code>double distance(genDType p0, genDType p1);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>p0</code> </em> </span> - Specifies the first of two points<dt><span> <em> <code>p1</code> </em> </span> - Specifies the second of two points</dt></dl></div></div><div><h2>Description</h2><p><code>distance</code> returns the distance between the two points <em><code>p0</code></em> and <em><code>p1</code></em>. i.e., <code><code>length</code>(<em><code>p0</code></em> - <em><code>p1</code></em>);</code></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>distance (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>distance (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#length><span><span>length</span></span></a>, <a href=#normalize><span><span>normalize</span></span></a></div></div>
<div id=dot><div></div><div><h2>Name</h2><p>dot — calculate the dot product of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>float dot(genType x, genType y);</code></table><table><tr><td><code>double dot(genDType x, genDType y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first of two vectors<dt><span> <em> <code>y</code> </em> </span> - Specifies the second of two vectors</dt></dl></div></div><div><h2>Description</h2><p><code>dot</code> returns the dot product of two vectors, <em><code>x</code></em> and <em><code>y</code></em>. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>x</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>0</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:mi>y</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>0</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo>+</mml:mo> <mml:mi>x</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:mi>y</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo>+</mml:mo> <mml:mo form=infix lspace=0px>...</mml:mo> </mml:math></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>dot (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dot (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#cross><span><span>cross</span></span></a></div></div>
<div id=EmitStreamVertex><div></div><div><h2>Name</h2><p>EmitStreamVertex — emit a vertex to a specified stream</div><div><h2>Declaration</h2><div><table><tr><td><code>void EmitStreamVertex(int stream);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>stream</code> </em> </span> - Specifies the stream upon which the vertex will be emitted.</dt></dl></div></div><div><h2>Description</h2><p><span><em>Available only in the Geometry Shader</em></span>, <code>EmitStreamVertex</code> emits the current values of output variables to the current output primitive on stream <em><code>stream</code></em>. The argument <em><code>stream</code></em> must be a constant integral expression. On return from this call, the value of all output variables for all streams are undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EmitStreamVertex<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitVertex><span><span>EmitVertex</span></span></a>, <a href=#EndStreamPrimitive><span><span>EndStreamPrimitive</span></span></a>, <a href=#EndPrimitive><span><span>EndPrimitive</span></span></a></div></div>
<div id=EndStreamPrimitive><div></div><div><h2>Name</h2><p>EndStreamPrimitive — complete the current output primitive on a specified stream</div><div><h2>Declaration</h2><div><table><tr><td><code>void EndStreamPrimitive(int stream);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>stream</code> </em> </span> - Specifies the stream upon which the current primitive will be ended.</dt></dl></div></div><div><h2>Description</h2><p><span><em>Available only in the Geometry Shader</em></span>, <code>EndStreamPrimitive</code> completes the current output primitive on stream <em><code>stream</code></em> and starts a new one. The argument to <em><code>stream</code></em> must be a constant integral expression. No vertex is emitted.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EndStreamPrimitive<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitVertex><span><span>EmitVertex</span></span></a>, <a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a>, <a href=#EndPrimitive><span><span>EndPrimitive</span></span></a></div></div>
<div id=equal><div></div><div><h2>Name</h2><p>equal — perform a component-wise equal-to comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec equal(vec x, vec y);</code></table><table><tr><td><code>bvec equal(ivec x, ivec y);</code></table><table><tr><td><code>bvec equal(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>x</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>equal</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] == <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>equal<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=exp><div></div><div><h2>Name</h2><p>exp — return the natural exponentiation of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType exp(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to exponentiate.</dt></dl></div></div><div><h2>Description</h2><p><code>exp</code> returns the natural exponentiation of <em><code>x</code></em>. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mi>e</mml:mi><mml:mi>x</mml:mi></mml:msup></mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>exp<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=exp2><div></div><div><h2>Name</h2><p>exp2 — return 2 raised to the power of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType exp2(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of the power to which 2 will be raised.</dt></dl></div></div><div><h2>Description</h2><p><code>exp2</code> returns 2 raised to the power of <em><code>x</code></em>. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup></mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>exp2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#exp><span><span>exp</span></span></a>, <a href=#log><span><span>log</span></span></a>, <a href=#log2><span><span>log2</span></span></a></div></div>
<div id=faceforward><div></div><div><h2>Name</h2><p>faceforward — return a vector pointing in the same direction as another</div><div><h2>Declaration</h2><div><table><tr><td><code>genType faceforward(genType N, genType I, genType Nref);</code></table><table><tr><td><code>genDType faceforward(genDType N, genDType I, genDType Nref);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>N</code> </em> </span> - Specifies the vector to orient.<dt><span> <em> <code>I</code> </em> </span> - Specifies the incident vector.<dt><span> <em> <code>Nref</code> </em> </span> - Specifies the reference vector.</dt></dl></div></div><div><h2>Description</h2><p><code>faceforward</code> orients a vector to point away from a surface as defined by its normal. If <a href=#dot><span><span>dot</span></span></a><code>(<em><code>Nref</code></em>, <em><code>I</code></em>) < 0</code> <code>faceforward</code> returns <em><code>N</code></em>, otherwise it returns <code>-<em><code>N</code></em></code>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>faceforward (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>faceforward (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#reflect><span><span>reflect</span></span></a>, <a href=#refract><span><span>refract</span></span></a></div></div>
<div id=findLSB><div></div><div><h2>Name</h2><p>findLSB — find the index of the least significant bit set to 1 in an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType findLSB(genIType value);</code></table><table><tr><td><code>genIType findLSB(genUType value);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>value</code> </em> </span> - Specifies the value whose bits to scan.</dt></dl></div></div><div><h2>Description</h2><p><code>findLSB</code> returns the bit number of the least significant bit that is set to 1 in the binary representation of <em><code>value</code></em>. If <em><code>value</code></em> is zero, -1 will be returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>findLSB<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findMSB><span><span>findMSB</span></span></a></div></div>
<div id=findMSB><div></div><div><h2>Name</h2><p>findMSB — find the index of the most significant bit set to 1 in an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType findMSB(genIType value);</code></table><table><tr><td><code>genIType findMSB(genUType value);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>value</code> </em> </span> - Specifies the value whose bits to scan.</dt></dl></div></div><div><h2>Description</h2><p><code>findMSB</code> returns the bit number of the most significant bit that is set to 1 in the binary representation of <em><code>value</code></em>. For positive integers, the result will be the bit number of the most significant bit that is set to 1. For negative integers, the result will be the bit number of the most significant bit set to 0. For a <em><code>value</code></em> of zero or negative 1, -1 will be returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>findMSB<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findLSB><span><span>findLSB</span></span></a></div></div>
<div id=floatBitsToInt><div></div><div><h2>Name</h2><p>floatBitsToInt — produce the encoding of a floating point value as an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genIType floatBitsToInt(genType x);</code></table><table><tr><td><code>genUType floatBitsToUint(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value whose floating point encoding to return.</dt></dl></div></div><div><h2>Description</h2><p><code>floatBitsToInt</code> and <code>floatBitsToUint</code> return the encoding of their floating-point parameters as <code>int</code> or <code>uint</code>, respectively. The floating-point bit-level representation is preserved.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>floatBitsToInt<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>floatBitsToUInt<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#intBitsToFloat><span><span>intBitsToFloat</span></span></a>, <code>uintBitsToFloat</code></div></div>
<div id=floor><div></div><div><h2>Name</h2><p>floor — find the nearest integer less than or equal to the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType floor(genType x);</code></table></div><div><table><tr><td><code>genDType floor(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>floor</code> returns a value equal to the nearest integer that is less than or equal to <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>floor (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>floor (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#trunc><span><span>trunc</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=fma><div></div><div><h2>Name</h2><p>fma — perform a fused multiply-add operation</div><div><h2>Declaration</h2><div><table><tr><td><code>genType fma(genType a, genType b, genType c);</code></table><table><tr><td><code>genDType fma(genDType a, genDType b, genDType c);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>a</code> </em> </span> - Specifies the first multiplicand.<dt><span> <em> <code>b</code> </em> </span> - Specifies the second multiplicand.<dt><span> <em> <code>c</code> </em> </span> - Specifies the value to be added to the result.</dt></dl></div></div><div><h2>Description</h2><p><code>fma</code> performs, where possible, a fused multiply-add operation, returning <code>a * b + c</code>. In use cases where the return value is eventually consumed by a variable declared as <code>precise</code>:<div><ul><li><p><code>fma</code>() is considered a single operation, whereas the expression <code>a * b + c</code> consumed by a variable declared as <code>precise</code> is considered two operations.</p><li><p>The precision of <code>fma</code>() can differ from the precision of the expression <code>a * b + c</code>.</p><li><p><code>fma</code>() will be computed with the same precision as any other <code>fma</code>() consumed by a <code>precise</code> variable, giving invariant results for the same input values of <em><code>a</code></em>, <em><code>b</code></em> and <em><code>c</code></em>.</p></ul></div><p>Otherwise, in the absence of <code>precise</code> consumption, there are no special constraints on the number of operations or difference in precision between <code>fma</code>() and the expression <code>a * b + c</code>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fma (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fma (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div></div>
<div id=fract><div></div><div><h2>Name</h2><p>fract — compute the fractional part of the argument</div><div><h2>Declaration</h2><div><table><tr><td><code>genType fract(genType x);</code></table></div><div><table><tr><td><code>genDType fract(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>fract</code> returns the fractional part of <em><code>x</code></em>. This is calculated as <em><code>x</code></em> - <a href=#floor><span><span>floor</span></span></a>(<em><code>x</code></em>).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fract (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fract (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=frexp><div></div><div><h2>Name</h2><p>frexp — split a floating point number</div><div><h2>Declaration</h2><div><table><tr><td><code>genType frexp(genType x, out genIType exp);</code></table><table><tr><td><code>genDType frexp(genDType x, out genIType exp);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value from which significand and exponent are to be extracted.<dt><span> <em> <code>out exp</code> </em> </span> - Specifies the variable into which to place the exponent</dt></dl></div></div><div><h2>Description</h2><p><code>frexp</code> extracts <em><code>x</code></em> into a floating-point significand in the range [0.5, 1.0) and in integral exponent of two, such that:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>x</mml:mi> <mml:mo>=</mml:mo> <mml:mi>significand</mml:mi> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:msup> <mml:mn>2</mml:mn> <mml:mi>exponent</mml:mi> </mml:msup> </mml:math><p>The significand is returned by the function and the exponent is returned in the output parameter <em><code>exp</code></em>. For a floating-point value of zero, the significand and exponent are both zero. For a floating-point value that is an infinity or a floating-point NaN, the results are undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>frexp (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>frexp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#ldexp><span><span>ldexp</span></span></a></div></div>
<div id=fwidth><div></div><div><h2>Name</h2><p>fwidth — return the sum of the absolute value of derivatives in x and y</div><div><h2>Declaration</h2><div><table><tr><td><code>genType fwidth(genType p);</code></table><table><tr><td><code>genType fwidthCoarse(genType p);</code></table><table><tr><td><code>genType fwidthFine(genType p);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>p</code> </em> </span> - Specifies the expression of which to take the partial derivative.</dt></dl></div></div><div><h2>Description</h2><p><span><em>Available only in the fragment shader</em></span>, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument <em><code>p</code></em>. <code>fwidth</code> is equivalent to <code>
    <code>abs</code>(<em><code>dFdx</code></em>(p)) +
    <code>abs</code>(<em><code>dFdy</code></em>(p))
</code>. <code>fwidthCoarse</code> is equivalent to <code>
    <code>abs</code>(<em><code>dFdxCoarse</code></em>(p)) +
    <code>abs</code>(<em><code>dFdyCoarse</code></em>(p))
</code>. <code>fwidthFine</code> is equivalent to <code>
    <code>abs</code>(<em><code>dFdxFine</code></em>(p)) +
    <code>abs</code>(<em><code>dFdyFine</code></em>(p))
</code>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fwidth<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fwidthCoarse, fwidthFine<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dFdx><span><span>dFdx</span></span></a></div></div>
<div id=greaterThan><div></div><div><h2>Name</h2><p>greaterThan — perform a component-wise greater-than comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec greaterThan(vec x, vec y);</code></table><table><tr><td><code>bvec greaterThan(ivec x, ivec y);</code></table><table><tr><td><code>bvec greaterThan(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>greaterThan</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] > <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>greaterThan (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThan (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThan (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=greaterThanEqual><div></div><div><h2>Name</h2><p>greaterThanEqual — perform a component-wise greater-than-or-equal comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec greaterThanEqual(vec x, vec y);</code></table><table><tr><td><code>bvec greaterThanEqual(ivec x, ivec y);</code></table><table><tr><td><code>bvec greaterThanEqual(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>greaterThanEqual</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] ≥ <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>greaterThanEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThanEqual (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThanEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=imageAtomicAdd><div></div><div><h2>Name</h2><p>imageAtomicAdd — atomically add a value to an existing value in memory and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicAdd(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicAdd(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to add<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to add the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to add into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to add into the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicAdd</code> atomically computes a new value by adding the value of <em><code>data</code></em> to the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicAdd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicAnd><div></div><div><h2>Name</h2><p>imageAtomicAnd — atomically compute the logical AND of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicAnd(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicAnd(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to logically AND into the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicAnd</code> atomically computes a new value by logically ANDing the value of <em><code>data</code></em> to the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicAnd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicCompSwap><div></div><div><h2>Name</h2><p>imageAtomicCompSwap — atomically compares supplied data with that in memory and conditionally stores it to memory</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicCompSwap(gimage1D image, int P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage2D image, ivec2 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage3D image, ivec3 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage2DRect image, ivec2 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimageCube image, ivec3 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gbufferImage image, int P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage1DArray image, ivec2 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage2DArray image, ivec3 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimageCubeArray image, ivec3 P, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, uint compare, uint data);</code></table><table><tr><td><code>uint imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, uint compare, uint data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage1D image, int P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage2D image, ivec2 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage3D image, ivec3 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage2DRect image, ivec2 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimageCube image, ivec3 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gbufferImage image, int P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage1DArray image, ivec2 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage2DArray image, ivec3 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimageCubeArray image, ivec3 P, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage2DMS image, ivec2 P, int sample, int compare, int data);</code></table><table><tr><td><code>int imageAtomicCompSwap(gimage2DMSArray image, ivec3 P, int sample, int compare, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to compare and conditionally store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to compare and conditionally store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to compare and conditionally store into.<dt><span> <em> <code>compare</code> </em> </span> - Specifies the value to compare with the content of the image.<dt><span> <em> <code>data</code> </em> </span> - Specifies the value to store in the image if</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicCompSwap</code> atomically compares the value of <em><code>compare</code></em> with that of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> (for multisampled forms) in the image bound to uint <em><code>image</code></em>. If the values are equal, <em><code>data</code></em> is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicCompSwap<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicExchange><div></div><div><h2>Name</h2><p>imageAtomicExchange — atomically store supplied data into memory and return the original value from memory</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicExchange(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage1D image, int P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2D image, ivec2 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage3D image, ivec3 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DRect image, ivec2 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimageCube image, ivec3 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gbufferImage image, int P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage1DArray image, ivec2 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DArray image, ivec3 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimageCubeArray image, ivec3 P, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DMS image, ivec2 P, int sample, float data);</code></table><table><tr><td><code>int imageAtomicExchange(gimage2DMSArray image, ivec3 P, int sample, float data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to exchange with that stored in the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicExchange</code> atomically stores the value of <em><code>data</code></em> into the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to unit <em><code>image</code></em>, and returns the original value of the texel.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicExchange (uint and int <em><code>data</code></em>)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>imageAtomicExchange (float <em><code>data</code></em>)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicMax><div></div><div><h2>Name</h2><p>imageAtomicMax — atomically compute the maximum of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicMax(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicMax(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicMax(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data of which to take the maximum with that stored in the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicMax</code> atomically computes a new value by finding the maximum of the value of <em><code>data</code></em> and the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicMax<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicMin><div></div><div><h2>Name</h2><p>imageAtomicMin — atomically compute the minimum of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicMin(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicMin(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicMin(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data of which to take the minimum with that stored in the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicMin</code> atomically computes a new value by finding the minimum of the value of <em><code>data</code></em> and the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicMin<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicOr><div></div><div><h2>Name</h2><p>imageAtomicOr — atomically compute the logical OR of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicOr(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicOr(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicOr(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to logically OR into the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicOr</code> atomically computes a new value by logically ORing the value of <em><code>data</code></em> to the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicOr<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicXor><div></div><div><h2>Name</h2><p>imageAtomicXor — atomically compute the logical exclusive OR of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td><code>uint imageAtomicXor(gimage1D image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage2D image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage3D image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage2DRect image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimageCube image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gbufferImage image, int P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage1DArray image, ivec2 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage2DArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimageCubeArray image, ivec3 P, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage2DMS image, ivec2 P, int sample, uint data);</code></table><table><tr><td><code>uint imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, uint data);</code></table><table><tr><td><code>int imageAtomicXor(gimage1D image, int P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage2D image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage3D image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage2DRect image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimageCube image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gbufferImage image, int P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage1DArray image, ivec2 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage2DArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimageCubeArray image, ivec3 P, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage2DMS image, ivec2 P, int sample, int data);</code></table><table><tr><td><code>int imageAtomicXor(gimage2DMSArray image, ivec3 P, int sample, int data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the data.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to logically XOR into the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageAtomicXor</code> atomically computes a new value by logically XORing the value of <em><code>data</code></em> to the contents of the texel at coordinate <em><code>P</code></em> and <em><code>sample</code></em> in the image bound to uint <em><code>image</code></em>, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicXor<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageLoad><div></div><div><h2>Name</h2><p>imageLoad — load a single texel from an image</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 imageLoad(gimage1D image, int P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage2D image, ivec2 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage3D image, ivec3 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage2DRect image, ivec2 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimageCube image, ivec3 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimageBuffer image, int P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage1DArray image, ivec2 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage2DArray image, ivec3 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimageCubeArray image, ivec3 P);</code></table><table><tr><td><code>gvec4 imageLoad(gimage2DMS image, ivec2 P, int sample);</code></table><table><tr><td><code>gvec4 imageLoad(gimage2DMSArray image, ivec3 P, int sample);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit from which to load a texel.<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate from which to load the texel.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to load</dt></dl></div></div><div><h2>Description</h2><p><code>imageLoad</code> loads the texel at the coordinate <em><code>P</code></em> from the image unit <em><code>image</code></em>. For multi-sample loads, the sample number is given by <em><code>sample</code></em>. When <em><code>image</code></em>, <em><code>P</code></em>, <em><code>sample</code></em> identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageLoad<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageSamples><div></div><div><h2>Name</h2><p>imageSamples — return the number of samples of an image</div><div><h2>Declaration</h2><div><table><tr><td><code>int imageSamples(gimage2DMS image);</code></table><table><tr><td><code>int imageSamples(gimage2DMSArray image);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specifies the image to which the texture is bound.</dt></dl></div></div><div><h2>Description</h2><p><code>imageSamples</code> returns the number of samples per texel of the image bound to <em><code>image</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageSamples<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#textureSamples><span><span>textureSamples</span></span></a></div></div>
<div id=imageSize><div></div><div><h2>Name</h2><p>imageSize — retrieve the dimensions of an image</div><div><h2>Declaration</h2><div><table><tr><td><code>int imageSize(gimage1D image);</code></table><table><tr><td><code>ivec2 imageSize(gimage2D image);</code></table><table><tr><td><code>ivec3 imageSize(gimage3D image);</code></table><table><tr><td><code>ivec2 imageSize(gimageCube image);</code></table><table><tr><td><code>ivec3 imageSize(gimageCubeArray image);</code></table><table><tr><td><code>ivec2 imageSize(gimageRect image);</code></table><table><tr><td><code>ivec2 imageSize(gimage1DArray image);</code></table><table><tr><td><code>ivec3 imageSize(gimage2DArray image);</code></table><table><tr><td><code>int imageSize(gimageBuffer image);</code></table><table><tr><td><code>ivec2 imageSize(gimage2DMS image);</code></table><table><tr><td><code>ivec3 imageSize(gimage2DMSArray image);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specifies the image to which the texture whose dimensions to retrieve is bound.</dt></dl></div></div><div><h2>Description</h2><p><code>imageSize</code> returns the dimensions of the image bound to <em><code>image</code></em>. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageSize<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#textureSize><span><span>textureSize</span></span></a>, <a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a></div></div>
<div id=imageStore><div></div><div><h2>Name</h2><p>imageStore — write a single texel into an image</div><div><h2>Declaration</h2><div><table><tr><td><code>void imageStore(gimage1D image, int P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage2D image, ivec2 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage3D image, ivec3 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage2DRect image, ivec2 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimageCube image, ivec3 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gbufferImage image, int P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage1DArray image, ivec2 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage2DArray image, ivec3 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimageCubeArray image, ivec3 P, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage2DMS image, ivec2 P, int sample, gvec4 data);</code></table><table><tr><td><code>void imageStore(gimage2DMSArray image, ivec3 P, int sample, gvec4 data);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>image</code> </em> </span> - Specify the image unit into which to store a texel.<dt><span> <em> <code>P</code> </em> </span> - Specify the coordinate at which to store the texel.<dt><span> <em> <code>sample</code> </em> </span> - When present, specifies the sample within the image to store into.<dt><span> <em> <code>data</code> </em> </span> - Specifies the data to store into the image.</dt></dl></div></div><div><h2>Description</h2><p><code>imageStore</code> stores <em><code>data</code></em> into the texel at the coordinate <em><code>P</code></em> from the image specified by <em><code>image</code></em>. For multi-sample stores, the sample number is given by <em><code>sample</code></em>. When <em><code>image</code></em>, <em><code>P</code></em>, and <em><code>sample</code></em> identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageStore<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=interpolateAtCentroid><div></div><div><h2>Name</h2><p>interpolateAtCentroid — sample a varying at the centroid of a pixel</div><div><h2>Declaration</h2><div><table><tr><td><code>float interpolateAtCentroid(float interpolant);</code></table><table><tr><td><code>vec2 interpolateAtCentroid(vec2 interpolant);</code></table><table><tr><td><code>vec3 interpolateAtCentroid(vec3 interpolant);</code></table><table><tr><td><code>vec4 interpolateAtCentroid(vec4 interpolant);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>interpolant</code> </em> </span> - Specifies the interpolant to be sampled at the pixel centroid.</dt></dl></div></div><div><h2>Description</h2><p><code>interpolateAtCentroid</code> returns the value of the input varying <em><code>interpolant</code></em> sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the <code>centroid</code> qualifier.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtCentroid<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtSample><span><span>interpolateAtSample</span></span></a>, <a href=#interpolateAtOffset><span><span>interpolateAtOffset</span></span></a></div></div>
<div id=interpolateAtOffset><div></div><div><h2>Name</h2><p>interpolateAtOffset — sample a varying at specified offset from the center of a pixel</div><div><h2>Declaration</h2><div><table><tr><td><code>float interpolateAtOffset(float interpolant, vec2 offset);</code></table><table><tr><td><code>vec2 interpolateAtOffset(vec2 interpolant, vec2 offset);</code></table><table><tr><td><code>vec3 interpolateAtOffset(vec3 interpolant, vec2 offset);</code></table><table><tr><td><code>vec4 interpolateAtOffset(vec4 interpolant, vec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>interpolant</code> </em> </span> - Specifies the interpolant to be sampled at the specified offset.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset from the center of the pixel at which to sample</dt></dl></div></div><div><h2>Description</h2><p><code>interpolateAtOffset</code> returns the value of the input varying <em><code>interpolant</code></em> sampled at an offset from the center of the pixel specified by <em><code>offset</code></em>. The two floating-point components of <em><code>offset</code></em> give the offset in pixels in the <span><em>x</em></span> and <span><em>y</em></span> directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtoOffset<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtCentroid><span><span>interpolateAtCentroid</span></span></a>, <a href=#interpolateAtSample><span><span>interpolateAtSample</span></span></a></div></div>
<div id=interpolateAtSample><div></div><div><h2>Name</h2><p>interpolateAtSample — sample a varying at the location of a specified sample</div><div><h2>Declaration</h2><div><table><tr><td><code>float interpolateAtSample(float interpolant, int sample);</code></table><table><tr><td><code>vec2 interpolateAtSample(vec2 interpolant, int sample);</code></table><table><tr><td><code>vec3 interpolateAtSample(vec3 interpolant, int sample);</code></table><table><tr><td><code>vec4 interpolateAtSample(vec4 interpolant, int sample);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>interpolant</code> </em> </span> - Specifies the interpolant to be sampled at the location of sample<dt><span> <em> <code>sample</code> </em> </span> - Specifies the index of the sample whose location will be used to sample</dt></dl></div></div><div><h2>Description</h2><p><code>interpolateAtSample</code> returns the value of the input varying <em><code>interpolant</code></em> sampled at the location of sample number <em><code>sample</code></em>. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample <em><code>sample</code></em> does not exist, the position used to interpolate the input varying is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtSample<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtCentroid><span><span>interpolateAtCentroid</span></span></a>, <a href=#interpolateAtOffset><span><span>interpolateAtOffset</span></span></a></div></div>
<div id=inverse><div></div><div><h2>Name</h2><p>inverse — calculate the inverse of a matrix</div><div><h2>Declaration</h2><div><table><tr><td><code>mat2 inverse(mat2 m);</code></table><table><tr><td><code>mat3 inverse(mat3 m);</code></table><table><tr><td><code>mat4 inverse(mat4 m);</code></table><table><tr><td><code>dmat2 inverse(dmat2 m);</code></table><table><tr><td><code>dmat3 inverse(dmat3 m);</code></table><table><tr><td><code>dmat4 inverse(dmat4 m);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>m</code> </em> </span> - Specifies the matrix of which to take the inverse.</dt></dl></div></div><div><h2>Description</h2><p><code>inverse</code> returns the inverse of the matrix <em><code>m</code></em>. The values in the returned matrix are undefined if <em><code>m</code></em> is singular or poorly-conditioned (nearly singular).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>inverse (float)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>inverse (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#transpose><span><span>transpose</span></span></a>, <a href=#determinant><span><span>determinant</span></span></a></div></div>
<div id=inversesqrt><div></div><div><h2>Name</h2><p>inversesqrt — return the inverse of the square root of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType inversesqrt(genType x);</code></table></div><div><table><tr><td><code>genDType inversesqrt(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of which to take the inverse of the square root.</dt></dl></div></div><div><h2>Description</h2><p><code>inversesqrt</code> returns the inverse of the square root of $x$; i.e. the value $1 \over { \sqrt x }$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>inversesqrt (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>inversesqrt (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#pow><span><span>pow</span></span></a>, <a href=#sqrt><span><span>sqrt</span></span></a></div></div>
<div id=isinf><div></div><div><h2>Name</h2><p>isinf — determine whether the parameter is positive or negative infinity</div><div><h2>Declaration</h2><div><table><tr><td><code>genBType isinf(genType x);</code></table><table><tr><td><code>genBType isinf(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value to test for infinity.</dt></dl></div></div><div><h2>Description</h2><p>For each element <span><em>i</em></span> of the result, <code>isinf</code> returns <code>true</code> if <em><code>x</code></em>[<span><em>i</em></span>] is positive or negative floating point infinity and false otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>isinf (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>isinf (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#isnan><span><span>isnan</span></span></a></div></div>
<div id=isnan><div></div><div><h2>Name</h2><p>isnan — determine whether the parameter is a number</div><div><h2>Declaration</h2><div><table><tr><td><code>genBType isnan(genType x);</code></table><table><tr><td><code>genBType isnan(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value to test for NaN.</dt></dl></div></div><div><h2>Description</h2><p>For each element <span><em>i</em></span> of the result, <code>isnan</code> returns <code>true</code> if <em><code>x</code></em>[<span><em>i</em></span>] is positive or negative floating point NaN (Not a Number) and false otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>isnan (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>isnan (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#isinf><span><span>isinf</span></span></a></div></div>
<div id=ldexp><div></div><div><h2>Name</h2><p>ldexp — assemble a floating point number from a value and exponent</div><div><h2>Declaration</h2><div><table><tr><td><code>genType ldexp(genType x, genIType exp);</code></table><table><tr><td><code>genDType ldexp(genDType x, genIType exp);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value to be used as a source of significand.<dt><span> <em> <code>out exp</code> </em> </span> - Specifies the value to be used as a source of exponent.</dt></dl></div></div><div><h2>Description</h2><p><code>ldexp</code> builds a floating point number from <em><code>x</code></em> and the corresponding integral exponent of two in <em><code>exp</code></em>, returning:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>significand</mml:mi> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:msup> <mml:mn>2</mml:mn> <mml:mi>exponent</mml:mi> </mml:msup> </mml:math><p>If this product is too large to be represented in the floating point type, the result is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>ldexp (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>ldexp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#frexp><span><span>frexp</span></span></a></div></div>
<div id=length><div></div><div><h2>Name</h2><p>length — calculate the length of a vector</div><div><h2>Declaration</h2><div><table><tr><td><code>float length(genType x);</code></table><table><tr><td><code>double length(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies a vector of which to calculate the length.</dt></dl></div></div><div><h2>Description</h2><p><code>length</code> returns the length of the vector, i.e. $\sqrt { { x[0] }^2 + { x[1] }^2 + \dots }$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>length (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>length (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#distance><span><span>distance</span></span></a>, <a href=#normalize><span><span>normalize</span></span></a></div></div>
<div id=lessThan><div></div><div><h2>Name</h2><p>lessThan — perform a component-wise less-than comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec lessThan(vec x, vec y);</code></table><table><tr><td><code>bvec lessThan(ivec x, ivec y);</code></table><table><tr><td><code>bvec lessThan(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>lessThan</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] < <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>lessThan (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThan (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThan (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=lessThanEqual><div></div><div><h2>Name</h2><p>lessThanEqual — perform a component-wise less-than-or-equal comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec lessThanEqual(vec x, vec y);</code></table><table><tr><td><code>bvec lessThanEqual(ivec x, ivec y);</code></table><table><tr><td><code>bvec lessThanEqual(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>lessThanEqual</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] ≤ <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>lessThanEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThanEqual (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThanEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=log><div></div><div><h2>Name</h2><p>log — return the natural logarithm of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType log(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of which to take the natural logarithm.</dt></dl></div></div><div><h2>Description</h2><p><code>log</code> returns the natural logarithm of $x$, i.e. the value $y$ which satisfies $x = e^y$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>log (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=log2><div></div><div><h2>Name</h2><p>log2 — return the base 2 logarithm of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType log2(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of which to take the base 2 logarithm.</dt></dl></div></div><div><h2>Description</h2><p><code>log2</code> returns the base 2 logarithm of $x$, i.e. the value $y$ which satisfies $x = 2^y$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>log2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#exp><span><span>exp</span></span></a>, <a href=#log><span><span>log</span></span></a>, <a href=#exp2><span><span>exp2</span></span></a></div></div>
<div id=matrixCompMult><div></div><div><h2>Name</h2><p>matrixCompMult — perform a component-wise multiplication of two matrices</div><div><h2>Declaration</h2><div><table><tr><td><code>mat matrixCompMult(mat x, mat y);</code></table><table><tr><td><code>dmat matrixCompMult(dmat x, dmat y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first matrix multiplicand.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second matrix multiplicand.</dt></dl></div></div><div><h2>Description</h2><p><code>matrixCompMult</code> performs a component-wise multiplication of two matrices, yielding a result matrix where each component, <code>result[i][j]</code> is computed as the scalar product of <code><em><code>x</code></em>[i][j]</code> and <code><em><code>y</code></em>[i][j]</code>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>matrixCompMult (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>matrixCompMult (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#reflect><span><span>reflect</span></span></a></div></div>
<div id=max><div></div><div><h2>Name</h2><p>max — return the greater of two values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType max(genType x, genType y);</code></table></div><div><table><tr><td><code>genType max(genType x, float y);</code></table></div><div><table><tr><td><code>genDType max(genDType x, genDType y);</code></table></div><div><table><tr><td><code>genDType max(genDType x, double y);</code></table></div><div><table><tr><td><code>genIType max(genIType x, genIType y);</code></table></div><div><table><tr><td><code>genIType max(genIType x, int y);</code></table></div><div><table><tr><td><code>genUType max(genUType x, genUType y);</code></table></div><div><table><tr><td><code>genUType max(genUType x, uint y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the first value to compare.<dt><span> <em> <code>y</code> </em> </span> - Specify the second value to compare.</dt></dl></div></div><div><h2>Description</h2><p><code>max</code> returns the maximum of the two parameters. It returns <em><code>y</code></em> if <em><code>y</code></em> is greater than <em><code>x</code></em>, otherwise it returns <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>max (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#abs><span><span>abs</span></span></a></div></div>
<div id=min><div></div><div><h2>Name</h2><p>min — return the lesser of two values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType min(genType x, genType y);</code></table></div><div><table><tr><td><code>genType min(genType x, float y);</code></table></div><div><table><tr><td><code>genDType min(genDType x, genDType y);</code></table></div><div><table><tr><td><code>genDType min(genDType x, double y);</code></table></div><div><table><tr><td><code>genIType min(genIType x, genIType y);</code></table></div><div><table><tr><td><code>genIType min(genIType x, int y);</code></table></div><div><table><tr><td><code>genUType min(genUType x, genUType y);</code></table></div><div><table><tr><td><code>genUType min(genUType x, uint y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the first value to compare.<dt><span> <em> <code>y</code> </em> </span> - Specify the second value to compare.</dt></dl></div></div><div><h2>Description</h2><p><code>min</code> returns the minimum of the two parameters. It returns <em><code>y</code></em> if <em><code>y</code></em> is less than <em><code>x</code></em>, otherwise it returns <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>min (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#max><span><span>max</span></span></a>, <a href=#abs><span><span>abs</span></span></a></div></div>
<div id=mix><div></div><div><h2>Name</h2><p>mix — linearly interpolate between two values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType mix(genType x, genType y, genType a);</code></table></div><div><table><tr><td><code>genType mix(genType x, genType y, float a);</code></table></div><div><table><tr><td><code>genDType mix(genDType x, genDType y, genDType a);</code></table></div><div><table><tr><td><code>genDType mix(genDType x, genDType y, double a);</code></table></div><div><table><tr><td><code>genType mix(genType x, genType y, genBType a);</code></table></div><div><table><tr><td><code>genDType mix(genDType x, genDType y, genBType a);</code></table></div><div><table><tr><td><code>genIType mix(genIType x, genIType y, genBType a);</code></table></div><div><table><tr><td><code>genUType mix(genUType x, genUType y, genBType a);</code></table></div><div><table><tr><td><code>genBType mix(genBType x, genBType y, genBType a);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the start of the range in which to interpolate.<dt><span> <em> <code>y</code> </em> </span> - Specify the end of the range in which to interpolate.<dt><span> <em> <code>a</code> </em> </span> - Specify the value to use to interpolate between</dt></dl></div></div><div><h2>Description</h2><p><code>mix</code> performs a linear interpolation between <em><code>x</code></em> and <em><code>y</code></em> using <em><code>a</code></em> to weight between them. The return value is computed as $x \times (1 - a) + y \times a$.<p>The variants of <code>mix</code> where <em><code>a</code></em> is <code>genBType</code> select which vector each returned component comes from. For a component of <em><code>a</code></em> that is false, the corresponding component of <em><code>x</code></em> is returned. For a component of <em><code>a</code></em> that is true, the corresponding component of <em><code>y</code></em> is returned. Components of <em><code>x</code></em> and <em><code>y</code></em> that are not selected are allowed to be invalid floating-point values and will have no effect on the results.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>mix(genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mix(genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mix(genIType), mix(genUType), mix(genBType)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#max><span><span>max</span></span></a></div></div>
<div id=mod><div></div><div><h2>Name</h2><p>mod — compute value of one parameter modulo another</div><div><h2>Declaration</h2><div><table><tr><td><code>genType mod(genType x, float y);</code></table></div><div><table><tr><td><code>genType mod(genType x, genType y);</code></table></div><div><table><tr><td><code>genDType mod(genDType x, double y);</code></table></div><div><table><tr><td><code>genDType mod(genDType x, genDType y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>mod</code> returns the value of <em><code>x</code></em> modulo <em><code>y</code></em>. This is computed as <em><code>x</code></em> - <em><code>y</code></em> * <a href=#floor><span><span>floor</span></span></a>(<em><code>x</code></em>/<em><code>y</code></em>).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>mod (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mod (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#modf><span><span>modf</span></span></a>, <a href=#floor><span><span>floor</span></span></a></div></div>
<div id=modf><div></div><div><h2>Name</h2><p>modf — separate a value into its integer and fractional components</div><div><h2>Declaration</h2><div><table><tr><td><code>genType modf(genType x, out genType i);</code></table></div><div><table><tr><td><code>genDType modf(genDType x, out genDType i);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to separate.<dt><span> <em> <code>out i</code> </em> </span> - A variable that receives the integer part of the argument.</dt></dl></div></div><div><h2>Description</h2><p><code>modf</code> separates a floating point value <em><code>x</code></em> into its integer and fractional parts. The fractional part of the number is returned from the function and the integer part (as a floating point quantity) is returned in the output parameter <em><code>i</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>modf (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>modf (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#fract><span><span>fract</span></span></a>, <a href=#floor><span><span>floor</span></span></a></div></div>
<div id=noise><div></div><div><h2>Name</h2><p>noise — generate values with a pseudo-random noise function</div><div><h2>Declaration</h2><div><table><tr><td><code>float noise1(genType x);</code></table><table><tr><td><code>vec2 noise2(genType x);</code></table><table><tr><td><code>vec3 noise3(genType x);</code></table><table><tr><td><code>vec4 noise4(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the value to be used to seed the noise function.</dt></dl></div></div><div><h2>Description</h2><p><code>noise1</code>, <code>noise2</code>, <code>noise3</code> and <code>noise4</code> return noise values (vector or scalar) based on the input value <em><code>x</code></em>. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:<p><div><ul><li><p>The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.</p><li><p>The return value(s) have an overall average of 0.0.</p><li><p>They are repeatable, in that a particular input value will always produce the same return value.</p><li><p>They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).</p><li><p>They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).</p><li><p>They typically give different results under translation.</p><li><p>The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.</p><li><p>They are C1 continuous everywhere (i.e., the first derivative is continuous).</p></ul></div><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>noise1<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise3<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise4<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div></div>
<div id=normalize><div></div><div><h2>Name</h2><p>normalize — calculates the unit vector in the same direction as the original vector</div><div><h2>Declaration</h2><div><table><tr><td><code>genType normalize(genType v);</code></table><table><tr><td><code>genDType normalize(genDType v);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>v</code> </em> </span> - Specifies the vector to normalize.</dt></dl></div></div><div><h2>Description</h2><p><code>normalize</code> returns a vector with the same direction as its parameter, <em><code>v</code></em>, but with length 1.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>normalize (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>normalize (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#length><span><span>length</span></span></a></div></div>
<div id=not><div></div><div><h2>Name</h2><p>not — logically invert a boolean vector</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec not(bvec x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the vector to be inverted.</dt></dl></div></div><div><h2>Description</h2><p><code>not</code> logically inverts the boolean vector <em><code>x</code></em>. It returns a new boolean vector for which each element <span><em>i</em></span> is computed as <code>!<em><code>x</code></em>[<em><code>i</code></em>]</code>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>not<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a></div></div>
<div id=notEqual><div></div><div><h2>Name</h2><p>notEqual — perform a component-wise not-equal-to comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>bvec notEqual(vec x, vec y);</code></table><table><tr><td><code>bvec notEqual(ivec x, ivec y);</code></table><table><tr><td><code>bvec notEqual(uvec x, uvec y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the comparison operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the comparison operation.</dt></dl></div></div><div><h2>Description</h2><p><code>notEqual</code> returns a boolean vector in which each element <span><em>i</em></span> is computed as <em><code>x</code></em>[<span><em>i</em></span>] != <em><code>y</code></em>[<span><em>i</em></span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>notEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>notEqual (ivec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>notEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=outerProduct><div></div><div><h2>Name</h2><p>outerProduct — calculate the outer product of a pair of vectors</div><div><h2>Declaration</h2><div><table><tr><td><code>mat2 outerProduct(vec2 c, vec2 r);</code></table><table><tr><td><code>mat3 outerProduct(vec3 c, vec3 r);</code></table><table><tr><td><code>mat4 outerProduct(vec4 c, vec4 r);</code></table><table><tr><td><code>mat2x3 outerProduct(vec3 c, vec2 r);</code></table><table><tr><td><code>mat3x2 outerProduct(vec2 c, vec3 r);</code></table><table><tr><td><code>mat2x4 outerProduct(vec4 c, vec2 r);</code></table><table><tr><td><code>mat4x2 outerProduct(vec2 c, vec4 r);</code></table><table><tr><td><code>mat3x4 outerProduct(vec4 c, vec3 r);</code></table><table><tr><td><code>mat4x3 outerProduct(vec3 c, vec4 r);</code></table><table><tr><td><code>dmat2 outerProduct(dvec2 c, dvec2 r);</code></table><table><tr><td><code>dmat3 outerProduct(dvec3 c, dvec3 r);</code></table><table><tr><td><code>dmat4 outerProduct(dvec4 c, dvec4 r);</code></table><table><tr><td><code>dmat2x3 outerProduct(dvec3 c, dvec2 r);</code></table><table><tr><td><code>dmat3x2 outerProduct(dvec2 c, dvec3 r);</code></table><table><tr><td><code>dmat2x4 outerProduct(dvec4 c, dvec2 r);</code></table><table><tr><td><code>dmat4x2 outerProduct(dvec2 c, dvec4 r);</code></table><table><tr><td><code>dmat3x4 outerProduct(dvec4 c, dvec3 r);</code></table><table><tr><td><code>dmat4x3 outerProduct(dvec3 c, dvec4 r);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>c</code> </em> </span> - Specifies the parameter to be treated as a column vector.<dt><span> <em> <code>r</code> </em> </span> - Specifies the parameter to be treated as a row vector.</dt></dl></div></div><div><h2>Description</h2><p><code>outerProduct</code> treats the first parameter <em><code>c</code></em> as a column vector (matrix with one column) and the second parameter <em><code>r</code></em> as a row vector (matrix with one row) and does a linear algebraic matrix multiply <em><code>c</code></em> * <em><code>r</code></em>, yielding a matrix whose number of rows is the number of components in <em><code>c</code></em> and whose number of columns is the number of components in <em><code>r</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>outerProduct (float)<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>outerProduct (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a></div></div>
<div id=packDouble2x32><div></div><div><h2>Name</h2><p>packDouble2x32 — create a double-precision value from a pair of unsigned integers</div><div><h2>Declaration</h2><div><table><tr><td><code>double packDouble2x32(uvec2 v);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>v</code> </em> </span> - Specifies a vector of two unsigned integers to be packed into a single double-precision result.</dt></dl></div></div><div><h2>Description</h2><p><code>packDouble2x32</code> packs the component of parameter <em><code>v</code></em> into a 64-bit value. If an IEEE-754 infinity or NaN is created, it will not signal and the resulting floating-point value is undefined. Otherwise, the bit-level representation of <em><code>v</code></em> is preserved. The first vector component (<code>v[0]</code>) specifies the 32 least significant bits of the result; the second component (<code>v[1]</code>) specifies the 32 most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packDouble2x32<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a></div></div>
<div id=packHalf2x16><div></div><div><h2>Name</h2><p>packHalf2x16 — convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer</div><div><h2>Declaration</h2><div><table><tr><td><code>uint packHalf2x16(vec2 v);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>v</code> </em> </span> - Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result.</dt></dl></div></div><div><h2>Description</h2><p><code>packHalf2x16</code> returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packHalf2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a>, <a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a>, <a href=#unpackHalf2x16><span><span>unpackHalf2x16</span></span></a></div></div>
<div id=packUnorm><div></div><div><h2>Name</h2><p>packUnorm — pack floating-point values into an unsigned integer</div><div><h2>Declaration</h2><div><table><tr><td><code>uint packUnorm2x16(vec2 v);</code></table><table><tr><td><code>uint packSnorm2x16(vec2 v);</code></table><table><tr><td><code>uint packUnorm4x8(vec4 v);</code></table><table><tr><td><code>uint packSnorm4x8(vec4 v);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>v</code> </em> </span> - Specifies a vector of values to be packed into an unsigned integer.</dt></dl></div></div><div><h2>Description</h2><p><code>packUnorm2x16</code>, <code>packSnorm2x16</code>, <code>packUnorm4x8</code> and <code>packSnorm4x8</code> convert each component of the normalized floating-ponit value <em><code>v</code></em> into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.<p>The conversion for component <em><code>c</code></em> of <em><code>v</code></em> to fixed-point is performed as follows:<div><ul><li><p><code>packUnorm2x16</code>: <code><code>round</code>(<code>clamp</code>(<em><code>c</code></em>, 0.0, 1.0) * 65535.0)</code></p><li><p><code>packSnorm2x16</code>: <code><code>round</code>(<code>clamp</code>(<em><code>c</code></em>, -1.0, 1.0) * 32767.0)</code></p><li><p><code>packUnorm4x8</code>: <code><code>round</code>(<code>clamp</code>(<em><code>c</code></em>, 0.0, 1.0) * 255.0)</code></p><li><p><code>packSnorm4x8</code>: <code><code>round</code>(<code>clamp</code>(<em><code>c</code></em>, -1.0, 1.0) * 127.0)</code></p></ul></div><p><p>The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packUnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>packSnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>packUnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>packSnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><code>unpackUnorm2x16</code>, <code>unpackSnorm2x16</code>, <code>unpackUnorm4x8</code>, <code>unpackSnorm4x8</code></div></div>
<div id=pow><div></div><div><h2>Name</h2><p>pow — return the value of the first parameter raised to the power of the second</div><div><h2>Declaration</h2><div><table><tr><td><code>genType pow(genType x, genType y);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to raise to the power<dt><span> <em> <code>y</code> </em> </span> - Specify the power to which to raise</dt></dl></div></div><div><h2>Description</h2><p><code>pow</code> returns the value of $x$ raised to the $y$ power, i.e. $x^y$. The result is undefined if $x < 0$ or if $x = 0$ and $y \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>pow<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=radians><div></div><div><h2>Name</h2><p>radians — convert a quantity in degrees to radians</div><div><h2>Declaration</h2><div><table><tr><td><code>genType radians(genType degrees);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>degrees</code> </em> </span> - Specify the quantity, in degrees, to be converted to radians.</dt></dl></div></div><div><h2>Description</h2><p><code>radians</code> converts a quantity specified in degrees into radians. The return value is ${ \pi \times degrees } \over 180$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>radians<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#degrees><span><span>degrees</span></span></a>,</div></div>
<div id=reflect><div></div><div><h2>Name</h2><p>reflect — calculate the reflection direction for an incident vector</div><div><h2>Declaration</h2><div><table><tr><td><code>genType reflect(genType I, genType N);</code></table><table><tr><td><code>genDType reflect(genDType I, genDType N);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>I</code> </em> </span> - Specifies the incident vector.<dt><span> <em> <code>N</code> </em> </span> - Specifies the normal vector.</dt></dl></div></div><div><h2>Description</h2><p>For a given incident vector <em><code>I</code></em> and surface normal <em><code>N</code></em> <code>reflect</code> returns the reflection direction calculated as <code><em><code>I</code></em> - 2.0 * <code>dot</code>(<em><code>N</code></em>, <em><code>I</code></em>) * <em><code>N</code></em></code>.<p><em><code>N</code></em> should be normalized in order to achieve the desired result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>reflect (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>reflect (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#refract><span><span>refract</span></span></a></div></div>
<div id=refract><div></div><div><h2>Name</h2><p>refract — calculate the refraction direction for an incident vector</div><div><h2>Declaration</h2><div><table><tr><td><code>genType refract(genType I, genType N, float eta);</code></table><table><tr><td><code>genDType refract(genDType I, genDType N, float eta);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>I</code> </em> </span> - Specifies the incident vector.<dt><span> <em> <code>N</code> </em> </span> - Specifies the normal vector.<dt><span> <em> <code>eta</code> </em> </span> - Specifies the ratio of indices of refraction.</dt></dl></div></div><div><h2>Description</h2><p>For a given incident vector <em><code>I</code></em>, surface normal <em><code>N</code></em> and ratio of indices of refraction, <em><code>eta</code></em>, <code>refract</code> returns the refraction vector, <em><code>R</code></em>.<p><em><code>R</code></em> is calculated as:<p><pre>    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
    if (k < 0.0)
        R = genType(0.0);       // or genDType(0.0)
    else
        R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;</pre><p><p>The input parameters <em><code>I</code></em> and <em><code>N</code></em> should be normalized in order to achieve the desired result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>refract (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>refract (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#reflect><span><span>reflect</span></span></a></div></div>
<div id=round><div></div><div><h2>Name</h2><p>round — find the nearest integer to the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType round(genType x);</code></table></div><div><table><tr><td><code>genDType round(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>round</code> returns a value equal to the nearest integer to <em><code>x</code></em>. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that <code>round</code>(<em><code>x</code></em>) returns the same value as <a href=#roundEven><span><span>roundEven</span></span></a>(<em><code>x</code></em>) for all values of <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>round (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>round (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#roundEven><span><span>roundEven</span></span></a></div></div>
<div id=roundEven><div></div><div><h2>Name</h2><p>roundEven — find the nearest even integer to the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType roundEven(genType x);</code></table></div><div><table><tr><td><code>genDType roundEven(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>roundEven</code> returns a value equal to the nearest integer to <em><code>x</code></em>. The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>roundEven (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>roundEven (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=sign><div></div><div><h2>Name</h2><p>sign — extract the sign of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType sign(genType x);</code></table></div><div><table><tr><td><code>genIType sign(genIType x);</code></table></div><div><table><tr><td><code>genDType sign(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value from which to extract the sign.</dt></dl></div></div><div><h2>Description</h2><p><code>sign</code> returns -1.0 if <em><code>x</code></em> is less than 0.0, 0.0 if <em><code>x</code></em> is equal to 0.0, and +1.0 if <em><code>x</code></em> is greater than 0.0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sign (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sign (genIType)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sign (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#abs><span><span>abs</span></span></a></div></div>
<div id=sin><div></div><div><h2>Name</h2><p>sin — return the sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType sin(genType angle);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>angle</code> </em> </span> - Specify the quantity, in radians, of which to return the sine.</dt></dl></div></div><div><h2>Description</h2><p><code>sin</code> returns the trigonometric sine of <em><code>angle</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sin<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#cos><span><span>cos</span></span></a>,</div></div>
<div id=sinh><div></div><div><h2>Name</h2><p>sinh — return the hyperbolic sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType sinh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose hyperbolic sine to return.</dt></dl></div></div><div><h2>Description</h2><p><code>sinh</code> returns the hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:msup> <mml:mi>e</mml:mi> <mml:mi>x</mml:mi> </mml:msup> <mml:mo>−</mml:mo> <mml:msup> <mml:mi>e</mml:mi> <mml:mrow> <mml:mo>−</mml:mo> <mml:mi>x</mml:mi> </mml:mrow> </mml:msup> </mml:mrow> <mml:mn>2</mml:mn> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sinh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=smoothstep><div></div><div><h2>Name</h2><p>smoothstep — perform Hermite interpolation between two values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType smoothstep(genType edge0, genType edge1, genType x);</code></table></div><div><table><tr><td><code>genType smoothstep(float edge0, float edge1, genType x);</code></table></div><div><table><tr><td><code>genDType smoothstep(genDType edge0, genDType edge1, genDType x);</code></table></div><div><table><tr><td><code>genDType smoothstep(double edge0, double edge1, genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>edge0</code> </em> </span> - Specifies the value of the lower edge of the Hermite function.<dt><span> <em> <code>edge1</code> </em> </span> - Specifies the value of the upper edge of the Hermite function.<dt><span> <em> <code>x</code> </em> </span> - Specifies the source value for interpolation.</dt></dl></div></div><div><h2>Description</h2><p><code>smoothstep</code> performs smooth Hermite interpolation between 0 and 1 when <em><code>edge0</code></em> < <em><code>x</code></em> < <em><code>edge1</code></em>. This is useful in cases where a threshold function with a smooth transition is desired. <code>smoothstep</code> is equivalent to:<p><pre>    genType t;  /* Or genDType t; */
    t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);</pre><p><p>Results are undefined if <em><code>edge0</code></em> ≥ <em><code>edge1</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>smoothstep (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>smoothstep (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#mix><span><span>mix</span></span></a>, <a href=#step><span><span>step</span></span></a></div></div>
<div id=sqrt><div></div><div><h2>Name</h2><p>sqrt — return the square root of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType sqrt(genType x);</code></table></div><div><table><tr><td><code>genDType sqrt(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value of which to take the square root.</dt></dl></div></div><div><h2>Description</h2><p><code>sqrt</code> returns the square root of $x$, i.e. the value $\sqrt { x }$. The result is undefined if $x < 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sqrt (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sqrt (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#pow><span><span>pow</span></span></a>, <a href=#inversesqrt><span><span>inversesqrt</span></span></a></div></div>
<div id=step><div></div><div><h2>Name</h2><p>step — generate a step function by comparing two values</div><div><h2>Declaration</h2><div><table><tr><td><code>genType step(genType edge, genType x);</code></table></div><div><table><tr><td><code>genType step(float edge, genType x);</code></table></div><div><table><tr><td><code>genDType step(genDType edge, genDType x);</code></table></div><div><table><tr><td><code>genDType step(double edge, genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>edge</code> </em> </span> - Specifies the location of the edge of the step function.<dt><span> <em> <code>x</code> </em> </span> - Specify the value to be used to generate the step function.</dt></dl></div></div><div><h2>Description</h2><p><code>step</code> generates a step function by comparing <em><code>x</code></em> to <em><code>edge</code></em>.<p>For element <span><em>i</em></span> of the return value, 0.0 is returned if <em><code>x</code></em>[<span><em>i</em></span>] < <em><code>edge</code></em>[<span><em>i</em></span>], and 1.0 is returned otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>step (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>step (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#mix><span><span>mix</span></span></a>, <a href=#smoothstep><span><span>smoothstep</span></span></a></div></div>
<div id=tan><div></div><div><h2>Name</h2><p>tan — return the tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType tan(genType angle);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>angle</code> </em> </span> - Specify the quantity, in radians, of which to return the tangent.</dt></dl></div></div><div><h2>Description</h2><p><code>tan</code> returns the trigonometric tangent of <em><code>angle</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>tan<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#atan><span><span>atan</span></span></a></div></div>
<div id=tanh><div></div><div><h2>Name</h2><p>tanh — return the hyperbolic tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType tanh(genType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value whose hyperbolic tangent to return.</dt></dl></div></div><div><h2>Description</h2><p><code>tanh</code> returns the hyperbolic tangent of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic tangent of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi mathvariant=italic>sinh</mml:mi> <mml:mo>⁡</mml:mo> <mml:mfenced close=) open=(> <mml:mi>x</mml:mi> </mml:mfenced> </mml:mrow> <mml:mrow> <mml:mi mathvariant=italic>cosh</mml:mi> <mml:mo>⁡</mml:mo> <mml:mfenced close=) open=(> <mml:mi>x</mml:mi> </mml:mfenced> </mml:mrow> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>tanh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=texelFetch><div></div><div><h2>Name</h2><p>texelFetch — perform a lookup of a single texel within a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 texelFetch(gsampler1D sampler, int P, int lod);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler2D sampler, ivec2 P, int lod);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler3D sampler, ivec3 P, int lod);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler2DRect sampler, ivec2 P);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler1DArray sampler, ivec2 P, int lod);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler2DArray sampler, ivec3 P, int lod);</code></table><table><tr><td><code>gvec4 texelFetch(gsamplerBuffer sampler, int P);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler2DMS sampler, ivec2 P, int sample);</code></table><table><tr><td><code>gvec4 texelFetch(gsampler2DMSArray sampler, ivec3 P, int sample);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - If present, specifies the level-of-detail within the texture from which the texel will be fetched.<dt><span> <em> <code>sample</code> </em> </span> - For multisampled fetches, specifies which sample within the texel from which will be returned.</dt></dl></div></div><div><h2>Description</h2><p><code>texelFetch</code> performs a lookup of a single texel from texture coordinate <em><code>P</code></em> in the texture bound to <em><code>sampler</code></em>. The array layer is specified in the last component of <em><code>P</code></em> for array forms. The <em><code>lod</code></em> parameter (if present) specifies the level-of-detail from which the texel will be fetched. The <em><code>sample</code></em> specifies which sample within the texel will be returned when reading from a multi-sample texure.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texelFetch<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetch (gsampler2DRect, gsamplerBuffer)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetch (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=texelFetchOffset><div></div><div><h2>Name</h2><p>texelFetchOffset — perform a lookup of a single texel within a texture with an offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 texelFetchOffset(gsampler1D sampler, int P, int lod, int offset);</code></table><table><tr><td><code>gvec4 texelFetchOffset(gsampler2D sampler, ivec2 P, int lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 texelFetchOffset(gsampler3D sampler, ivec3 P, int lod, ivec3 offset);</code></table><table><tr><td><code>gvec4 texelFetchOffset(gsampler2DRect sampler, ivec2 P, ivec2 offset);</code></table><table><tr><td><code>gvec4 texelFetchOffset(gsampler1DArray sampler, ivec2 P, int lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 texelFetchOffset(gsampler2DArray sampler, ivec3 P, int lod, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - If present, specifies the level-of-detail within the texture from which the texel will be fetched.<dt><span> <em> <code>offset</code> </em> </span> - Specifies offset, in texels that will be applied to</dt></dl></div></div><div><h2>Description</h2><p><code>texelFetchOffset</code> performs a lookup of a single texel from texture coordinate <em><code>P</code></em> in the texture bound to <em><code>sampler</code></em>. Before fetching the texel, the offset specified in <em><code>offset</code></em> is added to <em><code>P</code></em>. <em><code>offset</code></em> must be a constant expression. The array layer is specified in the last component of <em><code>P</code></em> for array forms. The <em><code>lod</code></em> parameter (if present) specifies the level-of-detail from which the texel will be fetched. The <em><code>sample</code></em> parameter specifies which sample within the texel will be returned when reading from a multi-sample texure.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texelFetchOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetchOffset (gsampler2DRect)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetchOffset (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=texture><div></div><div><h2>Name</h2><p>texture — retrieves texels from a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 texture(gsampler1D sampler, float P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsampler2D sampler, vec2 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsampler3D sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsamplerCube sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>float texture(sampler1DShadow sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>float texture(sampler2DShadow sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>float texture(samplerCubeShadow sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsampler1DArray sampler, vec2 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsampler2DArray sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsamplerCubeArray sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>float texture(sampler1DArrayShadow sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>float texture(sampler2DArrayShadow sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>gvec4 texture(gsampler2DRect sampler, vec2 P);</code></table><table><tr><td><code>float texture(sampler2DRectShadow sampler, vec3 P);</code></table><table><tr><td><code>float texture(samplerCubeArrayShadow sampler, vec4 P, float compare);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>bias</code> </em> </span> - Specifies an optional bias to be applied during level-of-detail computation.<dt><span> <em> <code>compare</code> </em> </span> - Specifies the value to which the fetched texel will be compared when sampling from</dt></dl></div></div><div><h2>Description</h2><p><code>texture</code> samples texels from the texture bound to <em><code>sampler</code></em> at texture coordinate <em><code>P</code></em>. An optional bias, specified in <em><code>bias</code></em> is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.<p>For <span><em>shadow</em></span> forms, when <em><code>compare</code></em> is present, it is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>sub</mml:mi></mml:msub></mml:math> and the array layer is specified in <code><em><code>P</code></em>.w</code>. When <em><code>compare</code></em> is not present, the last component of <em><code>P</code></em> is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>sub</mml:mi></mml:msub></mml:math> and the array layer is specified in the second to last component of <em><code>P</code></em>. (The second component of <em><code>P</code></em> is unused for <span><em>1D</em></span> shadow lookups.)<p>For non-shadow variants, the array layer comes from the last component of <em><code>P</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texture<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsamplerCubeArray{Shadow})<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGather><div></div><div><h2>Name</h2><p>textureGather — gathers four texels from a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureGather(gsampler2D sampler, vec2 P, [int comp]);</code></table><table><tr><td><code>gvec4 textureGather(gsampler2DArray sampler, vec3 P, [int comp]);</code></table><table><tr><td><code>gvec4 textureGather(gsamplerCube sampler, vec3 P, [int comp]);</code></table><table><tr><td><code>gvec4 textureGather(gsamplerCubeArray sampler, vec4 P, [int comp]);</code></table><table><tr><td><code>gvec4 textureGather(gsampler2DRect sampler, vec3 P, [int comp]);</code></table><table><tr><td><code>vec4 textureGather(sampler2DShadow sampler, vec2 P, float refZ);</code></table><table><tr><td><code>vec4 textureGather(sampler2DArrayShadow sampler, vec3 P, float refZ);</code></table><table><tr><td><code>vec4 textureGather(samplerCubeShadow sampler, vec3 P, float refZ);</code></table><table><tr><td><code>vec4 textureGather(samplerCubeArrayShadow sampler, vec4 P, float refZ);</code></table><table><tr><td><code>vec4 textureGather(sampler2DRectShadow sampler, vec2 P, float refZ);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>comp</code> </em> </span> - Specifies the component of the source texture that will be used to generate the resulting vector.<dt><span> <em> <code>refZ</code> </em> </span> - Specifies the reference Z value used in the comparison for shadow forms.</dt></dl></div></div><div><h2>Description</h2><p><code>textureGather</code> returns the value:<p><pre>    vec4(Sample_i0_j1(P, base).comp,
         Sample_i1_j1(P, base).comp,
         Sample_i1_j0(P, base).comp,
         Sample_i0_j0(P, base).comp);</pre><p><p>If specified, the value of <em><code>comp</code></em> must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If <em><code>comp</code></em> is not specified, it is treated as 0, selecting the x component of each texel to generate the result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGather<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGatherOffset><div></div><div><h2>Name</h2><p>textureGatherOffset — gathers four texels from a texture with offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureGatherOffset(gsampler2D sampler, vec2 P, ivec2 offset, [int comp]);</code></table><table><tr><td><code>gvec4 textureGatherOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [int comp]);</code></table><table><tr><td><code>gvec4 textureGatherOffset(gsampler2DRect sampler, vec3 P, ivec2 offset, [int comp]);</code></table><table><tr><td><code>vec4 textureGatherOffset(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offset);</code></table><table><tr><td><code>vec4 textureGatherOffset(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offset);</code></table><table><tr><td><code>vec4 textureGatherOffset(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>comp</code> </em> </span> - Specifies the component of the source texture that will be used to generate the resulting vector.<dt><span> <em> <code>refZ</code> </em> </span> - Specifies the reference Z value used in the comparison for shadow forms.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset from the specified texture coordinate</dt></dl></div></div><div><h2>Description</h2><p><code>textureGatherOffset</code> returns the value:<p><pre>    vec4(Sample_i0_j1(P + offset, base).comp,
         Sample_i1_j1(P + offset, base).comp,
         Sample_i1_j0(P + offset, base).comp,
         Sample_i0_j0(P + offset, base).comp);</pre><p><p>It perfoms as <a href=#textureGather><span><span>textureGather</span></span></a> but with <em><code>offset</code></em> applied as described in <a href=#textureOffset><span><span>textureOffset</span></span></a>, except that the implementation-dependent minimum and maximum offset values are given by <code>GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET</code> and <code>GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET</code>, respectively.<p>If specified, the value of <em><code>comp</code></em> must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If <em><code>comp</code></em> is not specified, it is treated as 0, selecting the x component of each texel to generate the result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGatherOffset<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGatherOffsets><div></div><div><h2>Name</h2><p>textureGatherOffsets — gathers four texels from a texture with an array of offsets</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureGatherOffsets(gsampler2D sampler, vec2 P, ivec2 offsets[4], [int comp]);</code></table><table><tr><td><code>gvec4 textureGatherOffsets(gsampler2DArray sampler, vec3 P, ivec2 offsets[4], [int comp]);</code></table><table><tr><td><code>gvec4 textureGatherOffsets(gsampler2DRect sampler, vec3 P, ivec2 offsets[4], [int comp]);</code></table><table><tr><td><code>vec4 textureGatherOffsets(sampler2DShadow sampler, vec2 P, float refZ, ivec2 offsets[4]);</code></table><table><tr><td><code>vec4 textureGatherOffsets(sampler2DArrayShadow sampler, vec3 P, float refZ, ivec2 offsets[4]);</code></table><table><tr><td><code>vec4 textureGatherOffsets(sampler2DRectShadow sampler, vec2 P, float refZ, ivec2 offsets[4]);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>comp</code> </em> </span> - Specifies the component of the source texture that will be used to generate the resulting vector.<dt><span> <em> <code>refZ</code> </em> </span> - Specifies the reference Z value used in the comparison for shadow forms.<dt><span> <em> <code>offsets</code> </em> </span> - Specifies an array of offsets from the specified texture coordinate</dt></dl></div></div><div><h2>Description</h2><p><code>textureGatherOffsets</code> operates identically to <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, except that <em><code>offsets</code></em> is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in <em><code>offsets</code></em> as a (u, v) coordinate offset to <em><code>P</code></em>, identifying the four-texel <code>GL_LINEAR</code> footprint, and then selecting the texel <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math> of that footprint. The specified values in <em><code>offsets</code></em> must be set with constant integral expressions.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGatherOffsets<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGrad><div></div><div><h2>Name</h2><p>textureGrad — perform a texture lookup with explicit gradients</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureGrad(gsampler1D sampler, float P, float dPdx, float dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsamplerCube sampler, vec3 P, vec3 dPdx, vec3 dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>float textureGrad(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>float textureGrad(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>float textureGrad(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy);</code></table><table><tr><td><code>float textureGrad(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>float textureGrad(samplerCubeShadow sampler, vec4 P, vec3 dPdx, vec3 dPdy);</code></table><table><tr><td><code>float textureGrad(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy);</code></table><table><tr><td><code>gvec4 textureGrad(gsamplerCubeArray sampler, vec4 P, vec3 dPdx, vec3 dPdy);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>dPdx</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>dPdy</code> </em> </span> - Specifies the partial derivative of</dt></dl></div></div><div><h2>Description</h2><p><code>textureGrad</code> performs a texture lookup at coordinate <em><code>P</code></em> from the texture bound to <em><code>sampler</code></em> with explicit texture coordinate gradiends as specified in <em><code>dPdx</code></em> and <em><code>dPdy</code></em>. Set:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δs</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mfrac> <mml:mi>δP</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi> for a 1D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.s</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δs</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mfrac> <mml:mi>δP</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi> for a 1D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.s</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δt</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi> for a 1D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.t</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δt</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi> for a 1D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.t</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δr</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi> for a 1D or 2D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.p</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δr</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi> for a 1D or 2D texture, </mml:mi> <mml:mfrac> <mml:mi>δP.p</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p>For the cube version, the partial derivatives of <em><code>P</code></em> are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGrad<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGrad (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGrad (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGradOffset><div></div><div><h2>Name</h2><p>textureGradOffset — perform a texture lookup with explicit gradients and offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureGradOffset(gsampler1D sampler, float P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>gvec4 textureGradOffset(gsampler2D sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureGradOffset(gsampler3D sampler, vec3 P, vec3 dPdx, vec3 dPdy, ivec3 offset);</code></table><table><tr><td><code>gvec4 textureGradOffset(gsampler2DRect sampler, vec2 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>float textureGradOffset(sampler2DRectShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>float textureGradOffset(sampler1DShadow sampler, vec3 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>float textureGradOffset(sampler2DShadow sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureGradOffset(gsampler1DArray sampler, vec2 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>gvec4 textureGradOffset(gsampler2DArray sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>float textureGradOffset(sampler1DArrayShadow sampler, vec3 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>float textureGradOffset(sampler2DArrayShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>dPdx</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>dPdy</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset to be applied to the texture coordinates before sampling.</dt></dl></div></div><div><h2>Description</h2><p><code>textureGradOffset</code> performs a texture lookup at coordinate <em><code>P</code></em> from the texture bound to <em><code>sampler</code></em> with explicit texture coordinate gradiends as specified in <em><code>dPdx</code></em> and <em><code>dPdy</code></em>. An explicit offset is also supplied in <em><code>offset</code></em>. <code>textureGradOffset</code> consumes <em><code>dPdx</code></em> and <em><code>dPdy</code></em> as <a href=#textureGrad><span><span>textureGrad</span></span></a> and <em><code>offset</code></em> as <a href=#textureOffset><span><span>textureOffset</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGradOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGradOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureLod><div></div><div><h2>Name</h2><p>textureLod — perform a texture lookup with explicit level-of-detail</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureLod(gsampler1D sampler, float P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsampler2D sampler, vec2 P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsampler3D sampler, vec3 P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsamplerCube sampler, vec3 P, float lod);</code></table><table><tr><td><code>float textureLod(sampler1DShadow sampler, vec3 P, float lod);</code></table><table><tr><td><code>float textureLod(sampler2DShadow sampler, vec3 P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsampler1DArray sampler, vec2 P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsampler2DArray sampler, vec3 P, float lod);</code></table><table><tr><td><code>float textureLod(sampler1DArrayShadow sampler, vec3 P, float lod);</code></table><table><tr><td><code>gvec4 textureLod(gsamplerCubeArray sampler, vec4 P, float lod);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - Specifies the explicit level-of-detail</dt></dl></div></div><div><h2>Description</h2><p><code>textureLod</code> performs a texture lookup at coordinate <em><code>P</code></em> from the texture bound to <em><code>sampler</code></em> with an explicit level-of-detail as specified in <em><code>lod</code></em>. <em><code>lod</code></em> specifies <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>λ</mml:mi><mml:mi>base</mml:mi></mml:msub></mml:math> and sets the partial derivatives as follows:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mtable rowalign=center> <mml:mtr> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>u</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>v</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>w</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> </mml:mrow> </mml:mtd> </mml:mtr> <mml:mtr> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>u</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>v</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>w</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> </mml:mrow> </mml:mtd> </mml:mtr> </mml:mtable> </mml:math></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureLod<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLod (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLod (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureLodOffset><div></div><div><h2>Name</h2><p>textureLodOffset — perform a texture lookup with explicit level-of-detail and offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureLodOffset(gsampler1D sampler, float P, float lod, int offset);</code></table><table><tr><td><code>gvec4 textureLodOffset(gsampler2D sampler, vec2 P, float lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureLodOffset(gsampler3D sampler, vec3 P, float lod, ivec3 offset);</code></table><table><tr><td><code>float textureLodOffset(sampler1DShadow sampler, vec3 P, float lod, int offset);</code></table><table><tr><td><code>float textureLodOffset(sampler2DShadow sampler, vec3 P, float lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureLodOffset(gsampler1DArray sampler, vec2 P, float lod, int offset);</code></table><table><tr><td><code>gvec4 textureLodOffset(gsampler2DArray sampler, vec3 P, float lod, ivec2 offset);</code></table><table><tr><td><code>float textureLodOffset(sampler1DArrayShadow sampler, vec3 P, float lod, int offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which the texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - Specifies the explicit level-of-detail from which texels will be fetched.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset that will be applied to</dt></dl></div></div><div><h2>Description</h2><p><code>textureLodOffset</code> performs a texture lookup at coordinate <em><code>P</code></em> from the texture bound to <em><code>sampler</code></em> with an explicit level-of-detail as specified in <em><code>lod</code></em>. Behavior is the same as in <a href=#textureLod><span><span>textureLod</span></span></a> except that before sampling, <em><code>offset</code></em> is added to <em><code>P</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureLodOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLodOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLodOffset (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureOffset><div></div><div><h2>Name</h2><p>textureOffset — perform a texture lookup with offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureOffset(gsampler1D sampler, float P, int offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureOffset(gsampler2D sampler, vec2 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureOffset(gsampler3D sampler, vec3 P, ivec3 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureOffset(gsampler2DRect sampler, vec2 P, ivec2 offset);</code></table><table><tr><td><code>float textureOffset(sampler2DRectShadow sampler, vec3 P, ivec2 offset);</code></table><table><tr><td><code>float textureOffset(sampler1DShadow sampler, vec3 P, int offset, [float bias]);</code></table><table><tr><td><code>float textureOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureOffset(gsampler1DArray sampler, vec2 P, int offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureOffset(gsampler2DArray sampler, vec3 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>float textureOffset(sampler1DArrayShadow sampler, vec3 P, int offset);</code></table><table><tr><td><code>float textureOffset(sampler2DArrayShadow sampler, vec4 P, vec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>offset</code> </em> </span> - Specifies offset, in texels that will be applied to</dt></dl></div></div><div><h2>Description</h2><p><code>textureOffset</code> performs a texture lookup at coordinate <em><code>P</code></em> from the texture bound to <em><code>sampler</code></em> with an additional offset, specified in texels in <em><code>offset</code></em> that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying <code>GL_MIN_PROGRAM_TEXEL_OFFSET</code> and <code>GL_MAX_PROGRAM_TEXEL_OFFSET</code>, respectively.<p>Note that <em><code>offset</code></em> does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProj><div></div><div><h2>Name</h2><p>textureProj — perform a texture lookup with projection</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProj(gsampler1D sampler, vec2 P, [float bias]);</code></table><table><tr><td><code>gvec4 textureProj(gsampler1D sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>gvec4 textureProj(gsampler2D sampler, vec3 P, [float bias]);</code></table><table><tr><td><code>gvec4 textureProj(gsampler2D sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>gvec4 textureProj(gsampler3D sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>float textureProj(sampler1DShadow sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>float textureProj(sampler2DShadow sampler, vec4 P, [float bias]);</code></table><table><tr><td><code>gvec4 textureProj(gsampler2DRect sampler, vec3 P);</code></table><table><tr><td><code>gvec4 textureProj(gsampler2DRect sampler, vec4 P);</code></table><table><tr><td><code>float textureProj(sampler2DRectShadow sampler, vec4 P);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>bias</code> </em> </span> - Specifies an optional bias to be applied during level-of-detail computation.</dt></dl></div></div><div><h2>Description</h2><p><code>textureProj</code> performs a texture lookup with projection. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#texture><span><span>texture</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProj<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProj (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjGrad><div></div><div><h2>Name</h2><p>textureProjGrad — perform a texture lookup with projection and explicit gradients</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProjGrad(gsampler1D sampler, vec2 P, float pDx, float pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler1D sampler, vec4 P, float pDx, float pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler2D sampler, vec3 P, vec2 pDx, vec2 pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler2D sampler, vec4 P, vec2 pDx, vec2 pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler3D sampler, vec4 P, vec3 pDx, vec3 pDy);</code></table><table><tr><td><code>float textureProjGrad(sampler1DShadow sampler, vec4 P, float pDx, float pDy);</code></table><table><tr><td><code>float textureProjGrad(sampler2DShadow sampler, vec4 P, vec2 pDx, vec2 pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler2DRect sampler, vec3 P, vec2 pDx, vec2 pDy);</code></table><table><tr><td><code>gvec4 textureProjGrad(gsampler2DRect sampler, vec4 P, vec2 pDx, vec2 pDy);</code></table><table><tr><td><code>float textureProjGrad(sampler2DRectShadow sampler, vec4 P, vec2 pDx, vec2 pDy);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>dPdx</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>dPdy</code> </em> </span> - Specifies the partial derivative of</dt></dl></div></div><div><h2>Description</h2><p><code>textureProjGrad</code> performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureGrad><span><span>textureGrad</span></span></a>, passing <em><code>dPdx</code></em> and <em><code>dPdy</code></em> as gradients.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjGrad<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjGrad (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjGradOffset><div></div><div><h2>Name</h2><p>textureProjGradOffset — perform a texture lookup with projection, explicit gradients and offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProjGradOffset(gsampler1D sampler, vec2 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler1D sampler, vec4 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler2D sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler2D sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler3D sampler, vec4 P, vec3 dPdx, vec3 dPdy, ivec3 offset);</code></table><table><tr><td><code>float textureProjGradOffset(sampler1DShadow sampler, vec4 P, float dPdx, float dPdy, int offset);</code></table><table><tr><td><code>float textureProjGradOffset(sampler2DShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler2DRect sampler, vec3 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjGradOffset(gsampler2DRect sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table><table><tr><td><code>float textureProjGradOffset(sampler2DRectShadow sampler, vec4 P, vec2 dPdx, vec2 dPdy, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>dPdx</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>dPdy</code> </em> </span> - Specifies the partial derivative of<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offsets, in texels at which the texture will be sampled relative to the projection of</dt></dl></div></div><div><h2>Description</h2><p><code>textureProjGradOffset</code> performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, passing <em><code>dPdx</code></em> and <em><code>dPdy</code></em> as gradients, and <em><code>offset</code></em> as the offset.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjGradOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjGradOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjLod><div></div><div><h2>Name</h2><p>textureProjLod — perform a texture lookup with projection and explicit level-of-detail</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProjLod(gsampler1D sampler, vec2 P, float lod);</code></table><table><tr><td><code>gvec4 textureProjLod(gsampler1D sampler, vec4 P, float lod);</code></table><table><tr><td><code>gvec4 textureProjLod(gsampler2D sampler, vec3 P, float lod);</code></table><table><tr><td><code>gvec4 textureProjLod(gsampler2D sampler, vec4 P, float lod);</code></table><table><tr><td><code>gvec4 textureProjLod(gsampler3D sampler, vec4 P, float lod);</code></table><table><tr><td><code>float textureProjLod(sampler1DShadow sampler, vec4 P, float lod);</code></table><table><tr><td><code>float textureProjLod(sampler2DShadow sampler, vec4 P, float lod);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - Specifies the explicit level-of-detail from which to fetch texels.</dt></dl></div></div><div><h2>Description</h2><p><code>textureProjLod</code> performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureLod><span><span>textureLod</span></span></a>, with <em><code>lod</code></em> used to specify the level-of-detail from which the texture will be sampled.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjLod<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjLodOffset><div></div><div><h2>Name</h2><p>textureProjLodOffset — perform a texture lookup with projection and explicit level-of-detail and offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProjLodOffset(gsampler1D sampler, vec2 P, float lod, int offset);</code></table><table><tr><td><code>gvec4 textureProjLodOffset(gsampler1D sampler, vec4 P, float lod, int offset);</code></table><table><tr><td><code>gvec4 textureProjLodOffset(gsampler2D sampler, vec3 P, float lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjLodOffset(gsampler2D sampler, vec4 P, float lod, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjLodOffset(gsampler3D sampler, vec4 P, float lod, ivec3 offset);</code></table><table><tr><td><code>float textureProjLodOffset(sampler1DShadow sampler, vec4 P, float lod, int offset);</code></table><table><tr><td><code>float textureProjLodOffset(sampler2DShadow sampler, vec4 P, float lod, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which texture will be sampled.<dt><span> <em> <code>lod</code> </em> </span> - Specifies the explicit level-of-detail from which to fetch texels.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset, in texels, to be applied to</dt></dl></div></div><div><h2>Description</h2><p><code>textureProjLodOffset</code> performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, with <em><code>lod</code></em> used to specify the level-of-detail from which the texture will be sampled and <em><code>offset</code></em> used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjLodOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjOffset><div></div><div><h2>Name</h2><p>textureProjOffset — perform a texture lookup with projection and offset</div><div><h2>Declaration</h2><div><table><tr><td><code>gvec4 textureProjOffset(gsampler1D sampler, vec2 P, int offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler1D sampler, vec4 P, int offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler2D sampler, vec3 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler2D sampler, vec4 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler3D sampler, vec4 P, ivec3 offset, [float bias]);</code></table><table><tr><td><code>float textureProjOffset(sampler1DShadow sampler, vec4 P, int offset, [float bias]);</code></table><table><tr><td><code>float textureProjOffset(sampler2DShadow sampler, vec4 P, ivec2 offset, [float bias]);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler2DRect sampler, vec3 P, ivec2 offset);</code></table><table><tr><td><code>gvec4 textureProjOffset(gsampler2DRect sampler, vec4 P, ivec2 offset);</code></table><table><tr><td><code>float textureProjOffset(sampler2DRectShadow sampler, vec4 P, ivec2 offset);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which the texture will be sampled.<dt><span> <em> <code>offset</code> </em> </span> - Specifies the offset that is applied to<dt><span> <em> <code>bias</code> </em> </span> - Specifies an optional bias to be applied during level-of-detail computation.</dt></dl></div></div><div><h2>Description</h2><p><code>textureProjOffset</code> performs a texture lookup with projection. The texture coordinates consumed from <em><code>P</code></em>, not including the last component of <em><code>P</code></em>, are divided by the last component of <em><code>P</code></em>. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of <em><code>P</code></em> in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureOffset><span><span>textureOffset</span></span></a>, with the <em><code>offset</code></em> used to offset the computed texture coordinates.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureQueryLevels><div></div><div><h2>Name</h2><p>textureQueryLevels — compute the number of accessible mipmap levels of a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>int textureQueryLevels(gsampler1D sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsampler2D sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsampler3D sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsamplerCube sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsampler1DArray sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsampler2DArray sampler);</code></table><table><tr><td><code>int textureQueryLevels(gsamplerCubeArray sampler);</code></table><table><tr><td><code>int textureQueryLevels(sampler1DShadow sampler);</code></table><table><tr><td><code>int textureQueryLevels(sampler2DShadow sampler);</code></table><table><tr><td><code>int textureQueryLevels(samplerCubeShadow sampler);</code></table><table><tr><td><code>int textureQueryLevels(sampler1DArrayShadow sampler);</code></table><table><tr><td><code>int textureQueryLevels(sampler2DArrayShadow sampler);</code></table><table><tr><td><code>int textureQueryLevels(samplerCubeArrayShadow sampler);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture whose mipmap level count will be queried is bound.</dt></dl></div></div><div><h2>Description</h2><p><code>textureQueryLevels</code> returns the number of accessible mipmap levels in the texture associated with <em><code>sampler</code></em>.<p>If called on an incomplete texture, or if no texture is associated with <em><code>sampler</code></em>, zero is returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureQueryLevels<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureQueryLod><div></div><div><h2>Name</h2><p>textureQueryLod — compute the level-of-detail that would be used to sample from a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>vec2 textureQueryLod(gsampler1D sampler, float P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsampler2D sampler, vec2 P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsampler3D sampler, vec3 P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsamplerCube sampler, vec3 P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsampler1DArray sampler, float P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsampler2DArray sampler, vec2 P);</code></table><table><tr><td><code>vec2 textureQueryLod(gsamplerCubeArray sampler, vec3 P);</code></table><table><tr><td><code>vec2 textureQueryLod(sampler1DShadow sampler, float P);</code></table><table><tr><td><code>vec2 textureQueryLod(sampler2DShadow sampler, vec2 P);</code></table><table><tr><td><code>vec2 textureQueryLod(samplerCubeShadow sampler, vec3 P);</code></table><table><tr><td><code>vec2 textureQueryLod(sampler1DArrayShadow sampler, float P);</code></table><table><tr><td><code>vec2 textureQueryLod(sampler2DArrayShadow sampler, vec2 P);</code></table><table><tr><td><code>vec2 textureQueryLod(samplerCubeArrayShadow sampler, vec3 P);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture whose level-of-detail will be queried is bound.<dt><span> <em> <code>P</code> </em> </span> - Specifies the texture coordinates at which the level-of-detail will be queried.</dt></dl></div></div><div><h2>Description</h2><p><span><em>Available only in the fragment shader</em></span>, <code>textureQueryLod</code> computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the <span><em>x</em></span> component of the return value. The computed level-of-detail relative to the base level is returned in the <span><em>y</em></span> component of the return value.<p>If called on an incomplete texture, the result of the operation is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureQueryLod<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureSamples><div></div><div><h2>Name</h2><p>textureSamples — return the number of samples of a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>int textureSamples(gsampler2DMS sampler);</code></table><table><tr><td><code>int textureSamples(gsampler2DMSArray sampler);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture is bound.</dt></dl></div></div><div><h2>Description</h2><p><code>textureSamples</code> returns the number of samples per texel of the texture bound to <em><code>sampler</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureSamples<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texture><span><span>texture</span></span></a>, <a href=#textureQueryLevels><span><span>textureQueryLevels</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureSize><div></div><div><h2>Name</h2><p>textureSize — retrieve the dimensions of a level of a texture</div><div><h2>Declaration</h2><div><table><tr><td><code>int textureSize(gsampler1D sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(gsampler2D sampler, int lod);</code></table><table><tr><td><code>ivec3 textureSize(gsampler3D sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(gsamplerCube sampler, int lod);</code></table><table><tr><td><code>int textureSize(sampler1DShadow sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(sampler2DShadow sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(samplerCubeShadow sampler, int lod);</code></table><table><tr><td><code>ivec3 textureSize(samplerCubeArray sampler, int lod);</code></table><table><tr><td><code>ivec3 textureSize(samplerCubeArrayShadow sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(gsampler2DRect sampler);</code></table><table><tr><td><code>ivec2 textureSize(sampler2DRectShadow sampler);</code></table><table><tr><td><code>ivec2 textureSize(gsampler1DArray sampler, int lod);</code></table><table><tr><td><code>ivec3 textureSize(gsampler2DArray sampler, int lod);</code></table><table><tr><td><code>ivec2 textureSize(sampler1DArrayShadow sampler, int lod);</code></table><table><tr><td><code>ivec3 textureSize(sampler2DArrayShadow sampler, int lod);</code></table><table><tr><td><code>int textureSize(gsamplerBuffer sampler);</code></table><table><tr><td><code>ivec2 textureSize(gsampler2DMS sampler);</code></table><table><tr><td><code>ivec3 textureSize(gsampler2DMSArray sampler);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>sampler</code> </em> </span> - Specifies the sampler to which the texture whose dimensions to retrieve is bound.<dt><span> <em> <code>lod</code> </em> </span> - Specifies the level of the texture for which to retrieve the dimensions.</dt></dl></div></div><div><h2>Description</h2><p><code>textureSize</code> returns the dimensions of level <em><code>lod</code></em> (if present) of the texture bound to <em><code>sampler</code></em>. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureSize<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureSize (samplerBuffer, sampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureSize (samplerCube{Shadow})<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a></div></div>
<div id=transpose><div></div><div><h2>Name</h2><p>transpose — calculate the transpose of a matrix</div><div><h2>Declaration</h2><div><table><tr><td><code>mat2 transpose(mat2 m);</code></table><table><tr><td><code>mat3 transpose(mat3 m);</code></table><table><tr><td><code>mat4 transpose(mat4 m);</code></table><table><tr><td><code>mat2x3 transpose(mat3x2 m);</code></table><table><tr><td><code>mat2x4 transpose(mat4x2 m);</code></table><table><tr><td><code>mat3x2 transpose(mat2x3 m);</code></table><table><tr><td><code>mat3x4 transpose(mat4x3 m);</code></table><table><tr><td><code>mat4x2 transpose(mat2x4 m);</code></table><table><tr><td><code>mat4x3 transpose(mat3x4 m);</code></table><table><tr><td><code>dmat2 transpose(dmat2 m);</code></table><table><tr><td><code>dmat3 transpose(dmat3 m);</code></table><table><tr><td><code>dmat4 transpose(dmat4 m);</code></table><table><tr><td><code>dmat2x3 transpose(dmat3x2 m);</code></table><table><tr><td><code>dmat2x4 transpose(dmat4x2 m);</code></table><table><tr><td><code>dmat3x2 transpose(dmat2x3 m);</code></table><table><tr><td><code>dmat3x4 transpose(dmat4x3 m);</code></table><table><tr><td><code>dmat4x2 transpose(dmat2x4 m);</code></table><table><tr><td><code>dmat4x3 transpose(dmat3x4 m);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>m</code> </em> </span> - Specifies the matrix of which to take the transpose.</dt></dl></div></div><div><h2>Description</h2><p><code>transpose</code> returns the transpose of the matrix <em><code>m</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>transpose (float)<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>transpose (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#determinant><span><span>determinant</span></span></a>, <a href=#inverse><span><span>inverse</span></span></a></div></div>
<div id=trunc><div></div><div><h2>Name</h2><p>trunc — find the truncated value of the parameter</div><div><h2>Declaration</h2><div><table><tr><td><code>genType trunc(genType x);</code></table></div><div><table><tr><td><code>genDType trunc(genDType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p><code>trunc</code> returns a value equal to the nearest integer to <em><code>x</code></em> whose absolute value is not larger than the absolute value of <em><code>x</code></em>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>trunc (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>trunc (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=uaddCarry><div></div><div><h2>Name</h2><p>uaddCarry — add unsigned integers and generate carry</div><div><h2>Declaration</h2><div><table><tr><td><code>genUType uaddCarry(genUType x, genUType y, out genUType carry);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the summation operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the summation operation.<dt><span> <em> <code>carry</code> </em> </span> - Specifies the variable to receive the carry output of the sum.</dt></dl></div></div><div><h2>Description</h2><p><code>uaddCarry</code> adds two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a carry output. The result is the sum of <em><code>x</code></em> and <em><code>y</code></em> modulo <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math>. The value <em><code>carry</code></em> is set to 0 if the sum is less than <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math> and to 1 otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>uaddCarry<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#usubBorrow><span><span>usubBorrow</span></span></a></div></div>
<div id=intBitsToFloat><div></div><div><h2>Name</h2><p>intBitsToFloat, uintBitsToFloat — produce a floating point using an encoding supplied as an integer</div><div><h2>Declaration</h2><div><table><tr><td><code>genType intBitsToFloat(genIType x);</code></table><table><tr><td><code>genType uintBitsToFloat(genUType x);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the bit encoding to return as a floating point value.</dt></dl></div></div><div><h2>Description</h2><p><code>intBitsToFloat</code> and <code>uintBitsToFloat</code> return the encoding passed in parameter <em><code>x</code></em> as a floating-point value. If the encoding of a NaN is passed in <em><code>x</code></em>, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter <em><code>x</code></em>, the resulting floating-point value is the corresponding (positive or negative) floating point infinity.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>intBitsToFloat<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floatBitsToInt><span><span>floatBitsToInt</span></span></a>, <code>floatBitsToUint</code>, <a href=#isnan><span><span>isnan</span></span></a>, <a href=#isinf><span><span>isinf</span></span></a></div></div>
<div id=umulExtended><div></div><div><h2>Name</h2><p>umulExtended — perform a 32- by 32-bit multiply to produce a 64-bit result</div><div><h2>Declaration</h2><div><table><tr><td><code>void umulExtended(genUType x, genUType y, out genUType msb, out genUType lsb);</code></table><table><tr><td><code>void imulExtended(genIType x, genIType y, out genIType msb, out genIType lsb);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first multiplicand.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second multiplicand.<dt><span> <em> <code>msb</code> </em> </span> - Specifies the variable to receive the most significant word of the product.<dt><span> <em> <code>lsb</code> </em> </span> - Specifies the variable to receive the least significant word of the product.</dt></dl></div></div><div><h2>Description</h2><p><code>umulExtended</code> and <code>imulExtended</code> perform multiplication of the two 32-bit integer quantities <em><code>x</code></em> and <em><code>y</code></em>, producing a 64-bit integer result. The 32 least significant bits of this product are returned in <em><code>lsb</code></em> and the 32 most significant bits are returned in <em><code>msb</code></em>. <code>umulExtended</code> and <code>imulExtended</code> perform unsigned and signed multiplication, respectively.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>umulExtended<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#uaddCarry><span><span>uaddCarry</span></span></a></div></div>
<div id=unpackDouble2x32><div></div><div><h2>Name</h2><p>unpackDouble2x32 — produce two unsigned integers containing the bit encoding of a double precision floating point value</div><div><h2>Declaration</h2><div><table><tr><td><code>uvec2 unpackDouble2x32(double d);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>d</code> </em> </span> - Specifies double precision value to break into a pair of unsigned integers.</dt></dl></div></div><div><h2>Description</h2><p><code>unpackDouble2x32</code> returns a two-component unsigned integer vector representation of <em><code>d</code></em>. The bit-level representation of <em><code>d</code></em> is preserved. The first component of the returned vector contains the 32 least significant bits of the double; the second component consists the 32 most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackDouble2x32<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a></div></div>
<div id=unpackHalf2x16><div></div><div><h2>Name</h2><p>unpackHalf2x16 — convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities</div><div><h2>Declaration</h2><div><table><tr><td><code>vec2 unpackHalf2x16(uint v);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>v</code> </em> </span> - Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked.</dt></dl></div></div><div><h2>Description</h2><p><code>unpackHalf2x16</code> returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most-significant bits of v.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackHalf2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a>, <a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a>, <a href=#packHalf2x16><span><span>packHalf2x16</span></span></a></div></div>
<div id=unpackUnorm><div></div><div><h2>Name</h2><p>unpackUnorm2x16, unpackUnorm4x8, unpackSnorm4x8 — unpack floating-point values from an unsigned integer</div><div><h2>Declaration</h2><div><table><tr><td><code>vec2 unpackUnorm2x16(uint p);</code></table><table><tr><td><code>vec2 unpackSnorm2x16(uint p);</code></table><table><tr><td><code>vec4 unpackUnorm4x8(uint p);</code></table><table><tr><td><code>vec4 unpackSnorm4x8(uint p);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>p</code> </em> </span> - Specifies an unsigned integer containing packed floating-point values.</dt></dl></div></div><div><h2>Description</h2><p><code>unpackUnorm2x16</code>, <code>unpackSnorm2x16</code>, <code>unpackUnorm4x8</code> and <code>unpackSnorm4x8</code> unpack single 32-bit unsigned integers, specified in the parameter <em><code>p</code></em> into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.<p>The conversion for unpacked fixed point value <span><em>f</em></span> to floating-point is performed as follows:<div><ul><li><p><code>packUnorm2x16</code>: <code>f / 65535.0</code></p><li><p><code>packSnorm2x16</code>: <code><code>clamp</code>(f / 32727.0, -1.0, 1.0)</code></p><li><p><code>packUnorm4x8</code>: <code>f / 255.0</code></p><li><p><code>packSnorm4x8</code>: <code><code>clamp</code>(f / 127.0, -1.0, 1.0)</code></p></ul></div><p><p>The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackUnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>unpackSnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>unpackUnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>unpackSnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><code>packUnorm2x16</code>, <code>packUnorm4x8</code>, <code>packSnorm4x8</code></div></div>
<div id=usubBorrow><div></div><div><h2>Name</h2><p>usubBorrow — subtract unsigned integers and generate borrow</div><div><h2>Declaration</h2><div><table><tr><td><code>genUType usubBorrow(genUType x, genUType y, out genUType borrow);</code></table></div></div><div><h2>Parameters</h2><div><dl><dt><span> <em> <code>x</code> </em> </span> - Specifies the first vector to be used in the subtraction operation.<dt><span> <em> <code>y</code> </em> </span> - Specifies the second vector to be used in the subtraction operation.<dt><span> <em> <code>borrow</code> </em> </span> - Specifies the variable to receive the borrow output of the difference.</dt></dl></div></div><div><h2>Description</h2><p><code>usubBorrow</code> subtracts two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a borrow output. The result is the difference of <em><code>x</code></em> and <em><code>y</code></em> if non-negative, or <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math> plus that difference otherwise. The value <em><code>borrow</code></em> is set to 0 if <em><code>x</code></em> ≥ <em><code>y</code></em> and to 1 otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>usubBorrow<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#uaddCarry><span><span>uaddCarry</span></span></a></div></div>
</body>
</html>