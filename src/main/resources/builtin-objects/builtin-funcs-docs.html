<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Glsl Builtin Functions</title>
</head>
<body>
<div id=abs><div></div><div><h2>Name</h2><p>abs — return the absolute value of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>abs</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genIType <strong>abs</strong>(genIType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>abs</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of which to return the absolute.</dt></dl></div></div><div><h2>Description</h2><p>abs returns the absolute value of x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>abs (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>abs (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>abs (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sign><span><span>sign</span></span></a></div></div>
<div id=acos><div></div><div><h2>Name</h2><p>acos — return the arccosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>acos</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose arccosine to return.</dt></dl></div></div><div><h2>Description</h2><p>acos returns the angle whose trigonometric cosine is $x$. The range of values returned by acos is $[0,\pi]$. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>acos<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#asin><span><span>asin</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=acosh><div></div><div><h2>Name</h2><p>acosh — return the arc hyperbolic cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>acosh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose arc hyperbolic cosine to return.</dt></dl></div></div><div><h2>Description</h2><p>acosh returns the arc hyperbolic cosine of $x$; the non-negative inverse of <a href=#cosh><span><span>cosh</span></span></a>. The result is undefined if $x < 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>acosh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=all><div></div><div><h2>Name</h2><p>all — check whether all elements of a boolean vector are true</div><div><h2>Declaration</h2><div><table><tr><td>bool <strong>all</strong>( bvec <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the vector to be tested for truth.</dt></dl></div></div><div><h2>Description</h2><p>all returns true if all elements of x are true and false otherwise. It is functionally equivalent to:<p><pre>    bool all(bvec x)       // bvec can be bvec2, bvec3 or bvec4
    {
        bool result = true;
        int i;
        for (i = 0; i < x.length(); ++i)
        {
            result &= x[i];
        }
        return result;
    }</pre><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>all<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#any><span><span>any</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=any><div></div><div><h2>Name</h2><p>any — check whether any element of a boolean vector is true</div><div><h2>Declaration</h2><div><table><tr><td>bool <strong>any</strong>( bvec <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the vector to be tested for truth.</dt></dl></div></div><div><h2>Description</h2><p>any returns true if any element of x is true and false otherwise. It is functionally equivalent to:<p><pre>    bool any(bvec x) {     // bvec can be bvec2, bvec3 or bvec4
        bool result = false;
        int i;
        for (i = 0; i < x.length(); ++i) {
            result |= x[i];
        }
        return result;
    }</pre><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>any<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=asin><div></div><div><h2>Name</h2><p>asin — return the arcsine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>asin</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose arcsine to return.</dt></dl></div></div><div><h2>Description</h2><p>asin returns the angle whose trigonometric sine is $x$. The range of values returned by asin is $[-{\pi \over 2}, {\pi \over 2}]$. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>asin<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#acos><span><span>acos</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=asinh><div></div><div><h2>Name</h2><p>asinh — return the arc hyperbolic sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>asinh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose arc hyperbolic sine to return.</dt></dl></div></div><div><h2>Description</h2><p>asinh returns the arc hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>; the inverse of <a href=#sinh><span><span>sinh</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>asinh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=atan><div></div><div><h2>Name</h2><p>atan — return the arc-tangent of the parameters</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>atan</strong>(genType <var>y</var>,<tr><td> genType <var>x</var>);</table></div><div><table><tr><td>genType <strong>atan</strong>(genType <var>y_over_x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> y </span> - Specify the numerator of the fraction whose arctangent to return.<dt><span> x </span><dd><p>Specify the denominator of the fraction whose arctangent to return.</p><dt><span> y_over_x </span><dd><p>Specify the fraction whose arctangent to return.</p></dl></div></div><div><h2>Description</h2><p>atan returns either the angle whose trigonometric arctangent is $y \over x$ or y_over_x, depending on which overload is invoked. In the first overload, the signs of $y$ and $x$ are used to determine the quadrant that the angle lies in. The value returned by atan in this case is in the range $[-\pi,\pi]$. The result is undefined if $x = 0$.<p>For the second overload, atan returns the angle whose tangent is y_over_x. The value returned in this case is in the range $[-{\pi \over 2 },{\pi \over 2}]$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atan<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#tan><span><span>tan</span></span></a></div></div>
<div id=atanh><div></div><div><h2>Name</h2><p>atanh — return the arc hyperbolic tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>atanh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose arc hyperbolic tangent to return.</dt></dl></div></div><div><h2>Description</h2><p>atanh returns the arc hyperbolic tangent of $x$; the inverse of <a href=#tanh><span><span>tanh</span></span></a>. The result is undefined if $\left| x \right| > 1$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atanh<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=atomicAdd><div></div><div><h2>Name</h2><p>atomicAdd — perform an atomic addition to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicAdd</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicAdd</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be added to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicAdd performs an atomic addition of data to the contents of mem and returns the original contents of mem from before the addition occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicAdd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicAnd><div></div><div><h2>Name</h2><p>atomicAnd — perform an atomic logical AND operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicAnd</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicAnd</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be logically ANDed with to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicAnd performs an atomic logical AND with data to the contents of mem and returns the original contents of mem from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicAnd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicCompSwap><div></div><div><h2>Name</h2><p>atomicCompSwap — perform an atomic compare-exchange operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicCompSwap</strong>( inout int <var>mem</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>atomicCompSwap</strong>( inout uint <var>mem</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be compared and potentially exchanged with mem.</p></dl></div></div><div><h2>Description</h2><p>atomicCompSwap performs an atomic comparison of compare with the contents of mem. If the content of mem is equal to compare, then the content of data is written into mem, otherwise the content of mem is unmodifed. The function returns the original content of mem regardless of the outcome of the comparison. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCompSwap<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a></div></div>
<div id=atomicCounter><div></div><div><h2>Name</h2><p>atomicCounter — return the current value of an atomic counter</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>atomicCounter</strong>( atomic_uint <var>c</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> c </span> - Specify the handle to the atomic counter whose value to return.</dt></dl></div></div><div><h2>Description</h2><p>atomicCounter returns the current value of the atomic counter c.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounter<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterIncrement><span><span>atomicCounterIncrement</span></span></a>, <a href=#atomicCounterDecrement><span><span>atomicCounterDecrement</span></span></a></div></div>
<div id=atomicCounterDecrement><div></div><div><h2>Name</h2><p>atomicCounterDecrement — atomically decrement a counter and return the prior value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>atomicCounterDecrement</strong>( atomic_uint <var>c</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> c </span> - Specify the handle to the atomic counter to decrement.</dt></dl></div></div><div><h2>Description</h2><p>atomicCounterDecrement atomically decrements the value of the atomic counter c and returns its new value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounterDecrement<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterIncrement><span><span>atomicCounterIncrement</span></span></a>, <a href=#atomicCounter><span><span>atomicCounter</span></span></a></div></div>
<div id=atomicCounterIncrement><div></div><div><h2>Name</h2><p>atomicCounterIncrement — atomically increment a counter and return the prior value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>atomicCounterIncrement</strong>( atomic_uint <var>c</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> c </span> - Specify the handle to the atomic counter to increment.</dt></dl></div></div><div><h2>Description</h2><p>atomicCounterIncrement atomically increments the value of the atomic counter c and returns its prior value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicCounterIncrement<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicCounterDecrement><span><span>atomicCounterDecrement</span></span></a>, <a href=#atomicCounter><span><span>atomicCounter</span></span></a></div></div>
<div id=atomicExchange><div></div><div><h2>Name</h2><p>atomicExchange — perform an atomic exchange operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicExchange</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicExchange</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be exchanged with mem.</p></dl></div></div><div><h2>Description</h2><p>atomicExchange performs an atomic exhange of data with the contents of mem. The content of data is written into mem and the original contents of mem are returned. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicExchange<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicMax><div></div><div><h2>Name</h2><p>atomicMax — perform an atomic max operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicMax</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicMax</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be compared to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicMax performs an atomic comparison of data to the contents of mem, writes the maximum value into mem and returns the original contents of mem from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicMax<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicMin><div></div><div><h2>Name</h2><p>atomicMin — perform an atomic min operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicMin</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicMin</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be compared to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicMin performs an atomic comparison of data to the contents of mem, writes the minimum value into mem and returns the original contents of mem from before the comparison occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicMin<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicOr><div></div><div><h2>Name</h2><p>atomicOr — perform an atomic logical OR operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicOr</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicOr</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be logically ORed with to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicOr performs an atomic logical OR with data to the contents of mem and returns the original contents of mem from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicOr<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicXor><span><span>atomicXor</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=atomicXor><div></div><div><h2>Name</h2><p>atomicXor — perform an atomic logical exclusive OR operation to a variable</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>atomicXor</strong>( inout int <var>mem</var>,<tr><td> int <var>data</var>);</table><table><tr><td>uint <strong>atomicXor</strong>( inout uint <var>mem</var>,<tr><td> uint <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> mem </span> - The variable to use as the target of the operation.<dt><span> data </span><dd><p>The data to be logically exclusive ORed with to mem.</p></dl></div></div><div><h2>Description</h2><p>atomicXor performs an atomic logical exclusive OR with data to the contents of mem and returns the original contents of mem from before the logical operation occurred. The contents of the memory being updated by the atomic operation are guaranteed not to be modified by any other assignment or atomic memory function in any shader invocation between the time the original value is read and the time the new value is written.<p>Atomic memory functions are supported only for a limited set of variables. A shader will fail to compile if the value passed to the mem argument of an atomic memory function does not correspond to a buffer or shared variable. It is acceptable to pass an element of an array or a single component of a vector to the mem argument of an atomic memory function, as long as the underlying array or vector is a buffer or shared variable.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>atomicXor<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#atomicAdd><span><span>atomicAdd</span></span></a>, <a href=#atomicAnd><span><span>atomicAnd</span></span></a>, <a href=#atomicOr><span><span>atomicOr</span></span></a>, <a href=#atomicMin><span><span>atomicMin</span></span></a>, <a href=#atomicMax><span><span>atomicMax</span></span></a>, <a href=#atomicExchange><span><span>atomicExchange</span></span></a>, <a href=#atomicCompSwap><span><span>atomicCompSwap</span></span></a></div></div>
<div id=barrier><div></div><div><h2>Name</h2><p>barrier — synchronize execution of multiple shader invocations</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>barrier</strong>( void);</table></div></div><div><h2>Description</h2><p><span>Available only in the Tessellation Control and Compute Shaders</span>, barrier provides a partially defined order of execution between shader invocations. For any given static instance of barrier, in a tessellation control shader, all invocations for a single input patch must enter it before any will be allowed to continue beyond it. For any given static instance of barrier in a compute shader, all invocations within a single work group must enter it before any are allowed to continue beyond it. This ensures that values written by one invocation prior to a given static instance of barrier can be safely read by other invocations after their call to the same static instance of barrier. Because invocations may execute in undefined order between these barrier calls, the values of a per-vertex or per-patch output variable, or any shared variable will be undefined in a number of cases.<p>barrier may only be placed inside the function main() of the tessellation control shader, but may be placed anywhere in a compute shader. Calls to barrier may not be placed within any control flow. Barriers are also disallowed after a return statement in the function main().</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>barrier<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div></div>
<div id=bitCount><div></div><div><h2>Name</h2><p>bitCount — counts the number of 1 bits in an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>bitCount</strong>(genIType <var>value</var>);</table><table><tr><td>genIType <strong>bitCount</strong>(genUType <var>value</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> value </span> - Specifies the value whose bits to count.</dt></dl></div></div><div><h2>Description</h2><p>bitCount returns the number of bits that are set to 1 in the binary representation of value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitCount<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findLSB><span><span>findLSB</span></span></a>, <a href=#findMSB><span><span>findMSB</span></span></a></div></div>
<div id=bitfieldExtract><div></div><div><h2>Name</h2><p>bitfieldExtract — extract a range of bits from an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>bitfieldExtract</strong>(genIType <var>value</var>,<tr><td> int <var>offset</var>,<tr><td> int <var>bits</var>);</table><table><tr><td>genUType <strong>bitfieldExtract</strong>(genUType <var>value</var>,<tr><td> int <var>offset</var>,<tr><td> int <var>bits</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> value </span> - Specifies the integer from which to extract bits.<dt><span> offset </span><dd><p>Specifies the index of the first bit to extract.</p><dt><span> bits </span><dd><p>Specifies the number of bits to extract.</p></dl></div></div><div><h2>Description</h2><p>bitfieldExtract extracts a subset of the bits of value and returns it in the least significant bits of the result. The range of bits extracted is [offset, offset + bits - 1].<p>For unsigned data types, the most significant bits of the result will be set to zero. For signed data types, the most significant bits will be set to the value of bit offset + base - 1 (i.e., it is <span>sign extended</span> to the width of the return type).<p>If bits is zero, the result will be zero. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldInsert<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a></div></div>
<div id=bitfieldInsert><div></div><div><h2>Name</h2><p>bitfieldInsert — insert a range of bits into an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>bitfieldInsert</strong>(genIType <var>base</var>,<tr><td> genIType <var>insert</var>,<tr><td> int <var>offset</var>,<tr><td> int <var>bits</var>);</table><table><tr><td>genUType <strong>bitfieldInsert</strong>(genUType <var>base</var>,<tr><td> genUType <var>insert</var>,<tr><td> int <var>offset</var>,<tr><td> int <var>bits</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> base </span> - Specifies the integer into which to insert - .<dt><span> insert </span><dd><p>Specifies the value of the bits to insert.</p><dt><span> offset </span><dd><p>Specifies the index of the first bit to insert.</p><dt><span> bits </span><dd><p>Specifies the number of bits to insert.</p></dl></div></div><div><h2>Description</h2><p>bitfieldInsert inserts the bits least significant bits of insert into base at offset offset. The returned value will have bits [offset, offset + bits + 1] taken from [0, bits - 1] of insert and all other bits taken directly from the corresponding bits of base. If bits is zero, the result will simply be the original value of base. The result will be undefined if offset or bits is negative, or if the sum of offset and bits is greater than the number of bits used to store the operand.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldInsert<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a></div></div>
<div id=bitfieldReverse><div></div><div><h2>Name</h2><p>bitfieldReverse — reverse the order of bits in an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>bitfieldReverse</strong>(genIType <var>value</var>);</table><table><tr><td>genUType <strong>bitfieldReverse</strong>(genUType <var>value</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> value </span> - Specifies the value whose bits to reverse.</dt></dl></div></div><div><h2>Description</h2><p>bitfieldReverse returns the reversal of the bits of value. The bit numbered <span>n</span> will be taken from bit (<span>bits</span> - 1) - <span>n</span> of value, where <span>bits</span> is the total number of bits used to represent value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>bitfieldReverse<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#bitfieldExtract><span><span>bitfieldExtract</span></span></a>, <a href=#bitfieldInsert><span><span>bitfieldInsert</span></span></a>, <a href=#bitCount><span><span>bitCount</span></span></a></div></div>
<div id=ceil><div></div><div><h2>Name</h2><p>ceil — find the nearest integer that is greater than or equal to the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>ceil</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>ceil</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>ceil returns a value equal to the nearest integer that is greater than or equal to x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>ceil (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>ceil (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=clamp><div></div><div><h2>Name</h2><p>clamp — constrain a value to lie between two further values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>clamp</strong>(genType <var>x</var>,<tr><td> genType <var>minVal</var>,<tr><td> genType <var>maxVal</var>);</table></div><div><table><tr><td>genType <strong>clamp</strong>(genType <var>x</var>,<tr><td> float <var>minVal</var>,<tr><td> float <var>maxVal</var>);</table></div><div><table><tr><td>genDType <strong>clamp</strong>(genDType <var>x</var>,<tr><td> genDType <var>minVal</var>,<tr><td> genDType <var>maxVal</var>);</table></div><div><table><tr><td>genDType <strong>clamp</strong>(genDType <var>x</var>,<tr><td> double <var>minVal</var>,<tr><td> double <var>maxVal</var>);</table></div><div><table><tr><td>genIType <strong>clamp</strong>(genIType <var>x</var>,<tr><td> genIType <var>minVal</var>,<tr><td> genIType <var>maxVal</var>);</table></div><div><table><tr><td>genIType <strong>clamp</strong>(genIType <var>x</var>,<tr><td> int <var>minVal</var>,<tr><td> int <var>maxVal</var>);</table></div><div><table><tr><td>genUType <strong>clamp</strong>(genUType <var>x</var>,<tr><td> genUType <var>minVal</var>,<tr><td> genUType <var>maxVal</var>);</table></div><div><table><tr><td>genUType <strong>clamp</strong>(genUType <var>x</var>,<tr><td> uint <var>minVal</var>,<tr><td> uint <var>maxVal</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to constrain.<dt><span> minVal </span><dd><p>Specify the lower end of the range into which to constrain x.</p><dt><span> maxVal </span><dd><p>Specify the upper end of the range into which to constrain x.</p></dl></div></div><div><h2>Description</h2><p>clamp returns the value of x constrained to the range minVal to maxVal. The returned value is computed as <a href=#min><span><span>min</span></span></a>(<a href=#max><span><span>max</span></span></a>(x, minVal), maxVal).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>clamp (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>clamp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#max><span><span>max</span></span></a></div></div>
<div id=cos><div></div><div><h2>Name</h2><p>cos — return the cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>cos</strong>(genType <var>angle</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> angle </span> - Specify the quantity, in radians, of which to return the cosine.</dt></dl></div></div><div><h2>Description</h2><p>cos returns the trigonometric cosine of angle.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cos<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a></div></div>
<div id=cosh><div></div><div><h2>Name</h2><p>cosh — return the hyperbolic cosine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>cosh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose hyperbolic cosine to return.</dt></dl></div></div><div><h2>Description</h2><p>cosh returns the hyperbolic cosine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic cosine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:msup> <mml:mi>e</mml:mi> <mml:mi>x</mml:mi> </mml:msup> <mml:mo>+</mml:mo> <mml:msup> <mml:mi>e</mml:mi> <mml:mrow> <mml:mo>−</mml:mo> <mml:mi>x</mml:mi> </mml:mrow> </mml:msup> </mml:mrow> <mml:mn>2</mml:mn> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cosh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a></div></div>
<div id=cross><div></div><div><h2>Name</h2><p>cross — calculate the cross product of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>vec3 <strong>cross</strong>( vec3 <var>x</var>,<tr><td> vec3 <var>y</var>);</table><table><tr><td>dvec3 <strong>cross</strong>( dvec3 <var>x</var>,<tr><td> dvec3 <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first of two vectors<dt><span> y </span><dd><p>Specifies the second of two vectors</p></dl></div></div><div><h2>Description</h2><p>cross returns the cross product of two vectors, x and y, i.e. $\begin{pmatrix} { x[1] \times y[2] - y[1] \times x[2] } \\ { x[2] \times y[0] - y[2] \times x[0] } \\ { x[0] \times y[1] - y[0] \times x[1] } \end{pmatrix}$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>cross (vec3)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>cross (dvec3)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a></div></div>
<div id=degrees><div></div><div><h2>Name</h2><p>degrees — convert a quantity in radians to degrees</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>degrees</strong>(genType <var>radians</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> radians </span> - Specify the quantity, in radians, to be converted to degrees.</dt></dl></div></div><div><h2>Description</h2><p>degrees converts a quantity specified in radians into degrees. The return value is ${ 180 \times radians } \over \pi$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>degrees<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#radians><span><span>radians</span></span></a></div></div>
<div id=determinant><div></div><div><h2>Name</h2><p>determinant — calculate the determinant of a matrix</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>determinant</strong>( mat2 <var>m</var>);</table><table><tr><td>float <strong>determinant</strong>( mat3 <var>m</var>);</table><table><tr><td>float <strong>determinant</strong>( mat4 <var>m</var>);</table><table><tr><td>double <strong>determinant</strong>( dmat2 <var>m</var>);</table><table><tr><td>double <strong>determinant</strong>( dmat3 <var>m</var>);</table><table><tr><td>double <strong>determinant</strong>( dmat4 <var>m</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> m </span> - Specifies the matrix of which to take the determinant.</dt></dl></div></div><div><h2>Description</h2><p>determinant returns the determinant of the matrix m.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>determinant (float)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>determinant (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#transpose><span><span>transpose</span></span></a>, <a href=#inverse><span><span>inverse</span></span></a></div></div>
<div id=dFdx><div></div><div><h2>Name</h2><p>dFdx, dFdy — return the partial derivative of an argument with respect to x or y</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>dFdx</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>dFdy</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>dFdxCoarse</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>dFdyCoarse</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>dFdxFine</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>dFdyFine</strong>(genType <var>p</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> p </span> - Specifies the expression of which to take the partial derivative.</dt></dl></div></div><div><h2>Description</h2><p><span>Available only in the fragment shader</span>, these functions return the partial derivative of expression p with respect to the window $x$ coordinate (for dFdx*) and $y$ coordinate (for dFdy*).<p>dFdxFine and dFdyFine calculate derivatives using local differencing based on the value of p for the current fragment and its immediate neighbor(s).<p>dFdxCoarse and dFdyCoarse calculate derivatives using local differencing based on the value of p for the current fragment's neighbors, and will possibly, but not necessarily, include the value for the current fragment. That is, over a given area, the implementation can compute derivatives in fewer unique locations than would be allowed for the corresponding dFdxFine and dFdyFine functions.<p>dFdx returns either dFdxCoarse or dFdxFine. dFdy returns either dFdyCoarse or dFdyFine. The implementation may choose which calculation to perform based upon factors such as performance or the value of the API GL_FRAGMENT_SHADER_DERIVATIVE_HINT hint.<p>Expressions that imply higher order derivatives such as dFdx(dFdx(n)) have undefined results, as do mixed-order derivatives such as dFdx(dFdy(n)). It is assumed that the expression p is continuous and therefore, expressions evaluated via non-uniform control flow may be undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>dFdx<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dFdy<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dFdxCoarse, dFdxFine, dFdyCoarse, dFdyFine<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#fwidth><span><span>fwidth</span></span></a>, <a href=#glHint><span><span>glHint</span></span></a></div></div>
<div id=distance><div></div><div><h2>Name</h2><p>distance — calculate the distance between two points</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>distance</strong>(genType <var>p0</var>,<tr><td> genType <var>p1</var>);</table><table><tr><td>double <strong>distance</strong>(genDType <var>p0</var>,<tr><td> genDType <var>p1</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> p0 </span> - Specifies the first of two points<dt><span> p1 </span><dd><p>Specifies the second of two points</p></dl></div></div><div><h2>Description</h2><p>distance returns the distance between the two points p0 and p1. i.e., length(p0 - p1);</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>distance (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>distance (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#length><span><span>length</span></span></a>, <a href=#normalize><span><span>normalize</span></span></a></div></div>
<div id=dot><div></div><div><h2>Name</h2><p>dot — calculate the dot product of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>dot</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>);</table><table><tr><td>double <strong>dot</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first of two vectors<dt><span> y </span><dd><p>Specifies the second of two vectors</p></dl></div></div><div><h2>Description</h2><p>dot returns the dot product of two vectors, x and y. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>x</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>0</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:mi>y</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>0</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo>+</mml:mo> <mml:mi>x</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:mi>y</mml:mi> <mml:mo stretchy=false>[</mml:mo> <mml:mn>1</mml:mn> <mml:mo stretchy=false>]</mml:mo> <mml:mo>+</mml:mo> <mml:mo form=infix lspace=0px>...</mml:mo> </mml:math></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>dot (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>dot (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#cross><span><span>cross</span></span></a></div></div>
<div id=EmitStreamVertex><div></div><div><h2>Name</h2><p>EmitStreamVertex — emit a vertex to a specified stream</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>EmitStreamVertex</strong>( int <var>stream</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> stream </span> - Specifies the stream upon which the vertex will be emitted.</dt></dl></div></div><div><h2>Description</h2><p><span>Available only in the Geometry Shader</span>, EmitStreamVertex emits the current values of output variables to the current output primitive on stream stream. The argument stream must be a constant integral expression. On return from this call, the value of all output variables for all streams are undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EmitStreamVertex<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitVertex><span><span>EmitVertex</span></span></a>, <a href=#EndStreamPrimitive><span><span>EndStreamPrimitive</span></span></a>, <a href=#EndPrimitive><span><span>EndPrimitive</span></span></a></div></div>
<div id=EmitVertex><div></div><div><h2>Name</h2><p>EmitVertex — emit a vertex to the first vertex stream</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>EmitVertex</strong>( void);</table></div></div><div><h2>Description</h2><p><span>Available only in the Geometry Shader</span>, EmitVertex emits the current values of output variables to the current output primitive on the first (and possibly only) primitive stream. It is equivalent to calling <a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a> with stream set to 0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EmitVertex<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a>, <a href=#EndStreamPrimitive><span><span>EndStreamPrimitive</span></span></a>, <a href=#EndPrimitive><span><span>EndPrimitive</span></span></a></div></div>
<div id=EndPrimitive><div></div><div><h2>Name</h2><p>EndPrimitive — complete the current output primitive on the first vertex stream</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>EndPrimitive</strong>( void);</table></div></div><div><h2>Description</h2><p><span>Available only in the Geometry Shader</span>, EndPrimitive completes the current output primitive on the first (and possibly only) vertex stream and starts a new one.No vertex is emitted. Calling EndPrimitive is equivalent to calling <a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a> with stream set to 0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EndPrimitive<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitVertex><span><span>EmitVertex</span></span></a>, <a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a>, <a href=#EndStreamPrimitive><span><span>EndStreamPrimitive</span></span></a></div></div>
<div id=EndStreamPrimitive><div></div><div><h2>Name</h2><p>EndStreamPrimitive — complete the current output primitive on a specified stream</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>EndStreamPrimitive</strong>( int <var>stream</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> stream </span> - Specifies the stream upon which the current primitive will be ended.</dt></dl></div></div><div><h2>Description</h2><p><span>Available only in the Geometry Shader</span>, EndStreamPrimitive completes the current output primitive on stream stream and starts a new one. The argument to stream must be a constant integral expression. No vertex is emitted.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>EndStreamPrimitive<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#EmitVertex><span><span>EmitVertex</span></span></a>, <a href=#EmitStreamVertex><span><span>EmitStreamVertex</span></span></a>, <a href=#EndPrimitive><span><span>EndPrimitive</span></span></a></div></div>
<div id=equal><div></div><div><h2>Name</h2><p>equal — perform a component-wise equal-to comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>equal</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>equal</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>equal</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> x </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>equal returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] == y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>equal<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=exp><div></div><div><h2>Name</h2><p>exp — return the natural exponentiation of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>exp</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to exponentiate.</dt></dl></div></div><div><h2>Description</h2><p>exp returns the natural exponentiation of x. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mi>e</mml:mi><mml:mi>x</mml:mi></mml:msup></mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>exp<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=exp2><div></div><div><h2>Name</h2><p>exp2 — return 2 raised to the power of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>exp2</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of the power to which 2 will be raised.</dt></dl></div></div><div><h2>Description</h2><p>exp2 returns 2 raised to the power of x. i.e., <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mi>x</mml:mi></mml:msup></mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>exp2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#exp><span><span>exp</span></span></a>, <a href=#log><span><span>log</span></span></a>, <a href=#log2><span><span>log2</span></span></a></div></div>
<div id=faceforward><div></div><div><h2>Name</h2><p>faceforward — return a vector pointing in the same direction as another</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>faceforward</strong>(genType <var>N</var>,<tr><td> genType <var>I</var>,<tr><td> genType <var>Nref</var>);</table><table><tr><td>genDType <strong>faceforward</strong>(genDType <var>N</var>,<tr><td> genDType <var>I</var>,<tr><td> genDType <var>Nref</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> N </span> - Specifies the vector to orient.<dt><span> I </span><dd><p>Specifies the incident vector.</p><dt><span> Nref </span><dd><p>Specifies the reference vector.</p></dl></div></div><div><h2>Description</h2><p>faceforward orients a vector to point away from a surface as defined by its normal. If <a href=#dot><span><span>dot</span></span></a>(Nref, I) < 0 faceforward returns N, otherwise it returns -N.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>faceforward (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>faceforward (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#reflect><span><span>reflect</span></span></a>, <a href=#refract><span><span>refract</span></span></a></div></div>
<div id=findLSB><div></div><div><h2>Name</h2><p>findLSB — find the index of the least significant bit set to 1 in an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>findLSB</strong>(genIType <var>value</var>);</table><table><tr><td>genIType <strong>findLSB</strong>(genUType <var>value</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> value </span> - Specifies the value whose bits to scan.</dt></dl></div></div><div><h2>Description</h2><p>findLSB returns the bit number of the least significant bit that is set to 1 in the binary representation of value. If value is zero, -1 will be returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>findLSB<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findMSB><span><span>findMSB</span></span></a></div></div>
<div id=findMSB><div></div><div><h2>Name</h2><p>findMSB — find the index of the most significant bit set to 1 in an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>findMSB</strong>(genIType <var>value</var>);</table><table><tr><td>genIType <strong>findMSB</strong>(genUType <var>value</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> value </span> - Specifies the value whose bits to scan.</dt></dl></div></div><div><h2>Description</h2><p>findMSB returns the bit number of the most significant bit that is set to 1 in the binary representation of value. For positive integers, the result will be the bit number of the most significant bit that is set to 1. For negative integers, the result will be the bit number of the most significant bit set to 0. For a value of zero or negative 1, -1 will be returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>findMSB<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#findLSB><span><span>findLSB</span></span></a></div></div>
<div id=floatBitsToInt><div></div><div><h2>Name</h2><p>floatBitsToInt — produce the encoding of a floating point value as an integer</div><div><h2>Declaration</h2><div><table><tr><td>genIType <strong>floatBitsToInt</strong>(genType <var>x</var>);</table><table><tr><td>genUType <strong>floatBitsToUint</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value whose floating point encoding to return.</dt></dl></div></div><div><h2>Description</h2><p>floatBitsToInt and floatBitsToUint return the encoding of their floating-point parameters as int or uint, respectively. The floating-point bit-level representation is preserved.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>floatBitsToInt<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>floatBitsToUInt<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#intBitsToFloat><span><span>intBitsToFloat</span></span></a>, uintBitsToFloat</div></div>
<div id=floor><div></div><div><h2>Name</h2><p>floor — find the nearest integer less than or equal to the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>floor</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>floor</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>floor returns a value equal to the nearest integer that is less than or equal to x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>floor (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>floor (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#trunc><span><span>trunc</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=fma><div></div><div><h2>Name</h2><p>fma — perform a fused multiply-add operation</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>fma</strong>(genType <var>a</var>,<tr><td> genType <var>b</var>,<tr><td> genType <var>c</var>);</table><table><tr><td>genDType <strong>fma</strong>(genDType <var>a</var>,<tr><td> genDType <var>b</var>,<tr><td> genDType <var>c</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> a </span> - Specifies the first multiplicand.<dt><span> b </span><dd><p>Specifies the second multiplicand.</p><dt><span> c </span><dd><p>Specifies the value to be added to the result.</p></dl></div></div><div><h2>Description</h2><p>fma performs, where possible, a fused multiply-add operation, returning a * b + c. In use cases where the return value is eventually consumed by a variable declared as precise:<div><ul><li><p>fma() is considered a single operation, whereas the expression a * b + c consumed by a variable declared as precise is considered two operations.</p><li><p>The precision of fma() can differ from the precision of the expression a * b + c.</p><li><p>fma() will be computed with the same precision as any other fma() consumed by a precise variable, giving invariant results for the same input values of a, b and c.</p></ul></div><p>Otherwise, in the absence of precise consumption, there are no special constraints on the number of operations or difference in precision between fma() and the expression a * b + c.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fma (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fma (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div></div>
<div id=fract><div></div><div><h2>Name</h2><p>fract — compute the fractional part of the argument</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>fract</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>fract</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>fract returns the fractional part of x. This is calculated as x - <a href=#floor><span><span>floor</span></span></a>(x).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fract (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fract (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=frexp><div></div><div><h2>Name</h2><p>frexp — split a floating point number</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>frexp</strong>(genType <var>x</var>,<tr><td> out genIType <var>exp</var>);</table><table><tr><td>genDType <strong>frexp</strong>(genDType <var>x</var>,<tr><td> out genIType <var>exp</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value from which significand and exponent are to be extracted.<dt><span> out exp </span><dd><p>Specifies the variable into which to place the exponent</p></dl></div></div><div><h2>Description</h2><p>frexp extracts x into a floating-point significand in the range [0.5, 1.0) and in integral exponent of two, such that:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>x</mml:mi> <mml:mo>=</mml:mo> <mml:mi>significand</mml:mi> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:msup> <mml:mn>2</mml:mn> <mml:mi>exponent</mml:mi> </mml:msup> </mml:math><p>The significand is returned by the function and the exponent is returned in the output parameter exp. For a floating-point value of zero, the significand and exponent are both zero. For a floating-point value that is an infinity or a floating-point NaN, the results are undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>frexp (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>frexp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#ldexp><span><span>ldexp</span></span></a></div></div>
<div id=fwidth><div></div><div><h2>Name</h2><p>fwidth — return the sum of the absolute value of derivatives in x and y</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>fwidth</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>fwidthCoarse</strong>(genType <var>p</var>);</table><table><tr><td>genType <strong>fwidthFine</strong>(genType <var>p</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> p </span> - Specifies the expression of which to take the partial derivative.</dt></dl></div></div><div><h2>Description</h2><p><span>Available only in the fragment shader</span>, these functions return the sum of the absolute derivatives in $x$ and $y$ using local differencing for the input argument p. fwidth is equivalent to abs(dFdx(p)) + abs(dFdy(p)) . fwidthCoarse is equivalent to abs(dFdxCoarse(p)) + abs(dFdyCoarse(p)) . fwidthFine is equivalent to abs(dFdxFine(p)) + abs(dFdyFine(p)) .</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>fwidth<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>fwidthCoarse, fwidthFine<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dFdx><span><span>dFdx</span></span></a></div></div>
<div id=greaterThan><div></div><div><h2>Name</h2><p>greaterThan — perform a component-wise greater-than comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>greaterThan</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>greaterThan</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>greaterThan</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>greaterThan returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] > y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>greaterThan (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThan (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThan (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=greaterThanEqual><div></div><div><h2>Name</h2><p>greaterThanEqual — perform a component-wise greater-than-or-equal comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>greaterThanEqual</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>greaterThanEqual</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>greaterThanEqual</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>greaterThanEqual returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] ≥ y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>greaterThanEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThanEqual (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>greaterThanEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=groupMemoryBarrier><div></div><div><h2>Name</h2><p>groupMemoryBarrier — controls the ordering of memory transaction issued shader invocation relative to a work group</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>groupMemoryBarrier</strong>( void);</table></div></div><div><h2>Description</h2><p>groupMemoryBarrier waits on the completion of all memory accesses performed by an invocation of a compute shader relative to the same access performed by other invocations in the same work group and then returns with no other effect.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>groupMemoryBarrier<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#memoryBarrier><span><span>memoryBarrier</span></span></a>, <a href=#memoryBarrierImage><span><span>memoryBarrierImage</span></span></a>, <a href=#memoryBarrierBuffer><span><span>memoryBarrierBuffer</span></span></a>, <a href=#memoryBarrierShared><span><span>memoryBarrierShared</span></span></a></div></div>
<div id=imageAtomicAdd><div></div><div><h2>Name</h2><p>imageAtomicAdd — atomically add a value to an existing value in memory and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAdd</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAdd</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to add - .<dt><span> P </span><dd><p>Specify the coordinate at which to add the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to add into.</p><dt><span> data </span><dd><p>Specifies the data to add into the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicAdd atomically computes a new value by adding the value of data to the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicAdd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicAnd><div></div><div><h2>Name</h2><p>imageAtomicAnd — atomically compute the logical AND of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicAnd</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicAnd</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data to logically AND into the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicAnd atomically computes a new value by logically ANDing the value of data to the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicAnd<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicCompSwap><div></div><div><h2>Name</h2><p>imageAtomicCompSwap — atomically compares supplied data with that in memory and conditionally stores it to memory</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicCompSwap</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>compare</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicCompSwap</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>compare</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to compare and conditionally store - .<dt><span> P </span><dd><p>Specify the coordinate at which to compare and conditionally store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to compare and conditionally store into.</p><dt><span> compare </span><dd><p>Specifies the value to compare with the content of the image.</p><dt><span> data </span><dd><p>Specifies the value to store in the image if compare is equal to the existing image content.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicCompSwap atomically compares the value of compare with that of the texel at coordinate P and sample (for multisampled forms) in the image bound to uint image. If the values are equal, data is stored into the texel, otherwise it is discarded. It returns the original value of the texel regardless of the result of the comparison operation.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicCompSwap<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicExchange><div></div><div><h2>Name</h2><p>imageAtomicExchange — atomically store supplied data into memory and return the original value from memory</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicExchange</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> float <var>data</var>);</table><table><tr><td>int <strong>imageAtomicExchange</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> float <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data to exchange with that stored in the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicExchange atomically stores the value of data into the texel at coordinate P and sample in the image bound to unit image, and returns the original value of the texel.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicExchange (uint and int data)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>imageAtomicExchange (float data)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicMax><div></div><div><h2>Name</h2><p>imageAtomicMax — atomically compute the maximum of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMax</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMax</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data of which to take the maximum with that stored in the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicMax atomically computes a new value by finding the maximum of the value of data and the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicMax<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicMin><div></div><div><h2>Name</h2><p>imageAtomicMin — atomically compute the minimum of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicMin</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicMin</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data of which to take the minimum with that stored in the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicMin atomically computes a new value by finding the minimum of the value of data and the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicMin<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicOr><div></div><div><h2>Name</h2><p>imageAtomicOr — atomically compute the logical OR of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicOr</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicOr</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data to logically OR into the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicOr atomically computes a new value by logically ORing the value of data to the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicOr<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageAtomicXor><div></div><div><h2>Name</h2><p>imageAtomicXor — atomically compute the logical exclusive OR of a value with an existing value in memory, store that value and return the original value</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>uint <strong>imageAtomicXor</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> uint <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table><table><tr><td>int <strong>imageAtomicXor</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> int <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store - .<dt><span> P </span><dd><p>Specify the coordinate at which to store the data.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data to logically XOR into the image.</p></dl></div></div><div><h2>Description</h2><p>imageAtomicXor atomically computes a new value by logically XORing the value of data to the contents of the texel at coordinate P and sample in the image bound to uint image, stores that value into the image and returns the original value.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageAtomicXor<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageLoad><div></div><div><h2>Name</h2><p>imageLoad — load a single texel from an image</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimageBuffer <var>image</var>,<tr><td> int <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>);</table><table><tr><td>gvec4 <strong>imageLoad</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit from which to load a texel.<dt><span> P </span><dd><p>Specify the coordinate from which to load the texel.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to load</p></dl></div></div><div><h2>Description</h2><p>imageLoad loads the texel at the coordinate P from the image unit image. For multi-sample loads, the sample number is given by sample. When image, P, sample identify a valid texel, the bits used to represent the selected texel in memory are converted to a vec4, ivec4, or uvec4 in the manner described in the OpenGL Specification and returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageLoad<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=imageSamples><div></div><div><h2>Name</h2><p>imageSamples — return the number of samples of an image</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>imageSamples</strong>( gimage2DMS <var>image</var>);</table><table><tr><td>int <strong>imageSamples</strong>( gimage2DMSArray <var>image</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specifies the image to which the texture is bound.</dt></dl></div></div><div><h2>Description</h2><p>imageSamples returns the number of samples per texel of the image bound to image.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageSamples<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#textureSamples><span><span>textureSamples</span></span></a></div></div>
<div id=imageSize><div></div><div><h2>Name</h2><p>imageSize — retrieve the dimensions of an image</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>imageSize</strong>( gimage1D <var>image</var>);</table><table><tr><td>ivec2 <strong>imageSize</strong>( gimage2D <var>image</var>);</table><table><tr><td>ivec3 <strong>imageSize</strong>( gimage3D <var>image</var>);</table><table><tr><td>ivec2 <strong>imageSize</strong>( gimageCube <var>image</var>);</table><table><tr><td>ivec3 <strong>imageSize</strong>( gimageCubeArray <var>image</var>);</table><table><tr><td>ivec2 <strong>imageSize</strong>( gimageRect <var>image</var>);</table><table><tr><td>ivec2 <strong>imageSize</strong>( gimage1DArray <var>image</var>);</table><table><tr><td>ivec3 <strong>imageSize</strong>( gimage2DArray <var>image</var>);</table><table><tr><td>int <strong>imageSize</strong>( gimageBuffer <var>image</var>);</table><table><tr><td>ivec2 <strong>imageSize</strong>( gimage2DMS <var>image</var>);</table><table><tr><td>ivec3 <strong>imageSize</strong>( gimage2DMSArray <var>image</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specifies the image to which the texture whose dimensions to retrieve is bound.</dt></dl></div></div><div><h2>Description</h2><p>imageSize returns the dimensions of the image bound to image. The components in the return value are filled in, in order, with the width, height and depth of the image. For the array forms, the last component of the return value is the number of layers in the texture array.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageSize<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#textureSize><span><span>textureSize</span></span></a>, <a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a></div></div>
<div id=imageStore><div></div><div><h2>Name</h2><p>imageStore — write a single texel into an image</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>imageStore</strong>( gimage1D <var>image</var>,<tr><td> int <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage2D <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage3D <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage2DRect <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimageCube <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gbufferImage <var>image</var>,<tr><td> int <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage1DArray <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage2DArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimageCubeArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage2DMS <var>image</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> gvec4 <var>data</var>);</table><table><tr><td>void <strong>imageStore</strong>( gimage2DMSArray <var>image</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>,<tr><td> gvec4 <var>data</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> image </span> - Specify the image unit into which to store a texel.<dt><span> P </span><dd><p>Specify the coordinate at which to store the texel.</p><dt><span> sample </span><dd><p>When present, specifies the sample within the image to store into.</p><dt><span> data </span><dd><p>Specifies the data to store into the image.</p></dl></div></div><div><h2>Description</h2><p>imageStore stores data into the texel at the coordinate P from the image specified by image. For multi-sample stores, the sample number is given by sample. When image, P, and sample identify a valid texel, the bits used to represent data are converted to the format of the image unit in the manner described in of the OpenGL Specification and stored to the specified texel.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>imageStore<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a></div></div>
<div id=interpolateAtCentroid><div></div><div><h2>Name</h2><p>interpolateAtCentroid — sample a varying at the centroid of a pixel</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>interpolateAtCentroid</strong>( float <var>interpolant</var>);</table><table><tr><td>vec2 <strong>interpolateAtCentroid</strong>( vec2 <var>interpolant</var>);</table><table><tr><td>vec3 <strong>interpolateAtCentroid</strong>( vec3 <var>interpolant</var>);</table><table><tr><td>vec4 <strong>interpolateAtCentroid</strong>( vec4 <var>interpolant</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> interpolant </span> - Specifies the interpolant to be sampled at the pixel centroid.</dt></dl></div></div><div><h2>Description</h2><p>interpolateAtCentroid returns the value of the input varying interpolant sampled at a location inside both the pixel and the primitive being processed. The value obtained would be the value assigned to the input variable if declared with the centroid qualifier.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtCentroid<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtSample><span><span>interpolateAtSample</span></span></a>, <a href=#interpolateAtOffset><span><span>interpolateAtOffset</span></span></a></div></div>
<div id=interpolateAtOffset><div></div><div><h2>Name</h2><p>interpolateAtOffset — sample a varying at specified offset from the center of a pixel</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>interpolateAtOffset</strong>( float <var>interpolant</var>,<tr><td> vec2 <var>offset</var>);</table><table><tr><td>vec2 <strong>interpolateAtOffset</strong>( vec2 <var>interpolant</var>,<tr><td> vec2 <var>offset</var>);</table><table><tr><td>vec3 <strong>interpolateAtOffset</strong>( vec3 <var>interpolant</var>,<tr><td> vec2 <var>offset</var>);</table><table><tr><td>vec4 <strong>interpolateAtOffset</strong>( vec4 <var>interpolant</var>,<tr><td> vec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> interpolant </span> - Specifies the interpolant to be sampled at the specified offset.<dt><span> offset </span><dd><p>Specifies the offset from the center of the pixel at which to sample interpolant.</p></dl></div></div><div><h2>Description</h2><p>interpolateAtOffset returns the value of the input varying interpolant sampled at an offset from the center of the pixel specified by offset. The two floating-point components of offset give the offset in pixels in the <span>x</span> and <span>y</span> directions from the center of the pixel, respectively. An offset of (0, 0) identifies the center of the pixel. The range and granularity of offsets supported by this function is implementation-dependent.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtoOffset<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtCentroid><span><span>interpolateAtCentroid</span></span></a>, <a href=#interpolateAtSample><span><span>interpolateAtSample</span></span></a></div></div>
<div id=interpolateAtSample><div></div><div><h2>Name</h2><p>interpolateAtSample — sample a varying at the location of a specified sample</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>interpolateAtSample</strong>( float <var>interpolant</var>,<tr><td> int <var>sample</var>);</table><table><tr><td>vec2 <strong>interpolateAtSample</strong>( vec2 <var>interpolant</var>,<tr><td> int <var>sample</var>);</table><table><tr><td>vec3 <strong>interpolateAtSample</strong>( vec3 <var>interpolant</var>,<tr><td> int <var>sample</var>);</table><table><tr><td>vec4 <strong>interpolateAtSample</strong>( vec4 <var>interpolant</var>,<tr><td> int <var>sample</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> interpolant </span> - Specifies the interpolant to be sampled at the location of sample - .<dt><span> sample </span><dd><p>Specifies the index of the sample whose location will be used to sample interpolant.</p></dl></div></div><div><h2>Description</h2><p>interpolateAtSample returns the value of the input varying interpolant sampled at the location of sample number sample. If multisample buffers are not available, the input varying will be evaluated at the center of the pixel. If sample sample does not exist, the position used to interpolate the input varying is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>interpolateAtSample<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#interpolateAtCentroid><span><span>interpolateAtCentroid</span></span></a>, <a href=#interpolateAtOffset><span><span>interpolateAtOffset</span></span></a></div></div>
<div id=inverse><div></div><div><h2>Name</h2><p>inverse — calculate the inverse of a matrix</div><div><h2>Declaration</h2><div><table><tr><td>mat2 <strong>inverse</strong>( mat2 <var>m</var>);</table><table><tr><td>mat3 <strong>inverse</strong>( mat3 <var>m</var>);</table><table><tr><td>mat4 <strong>inverse</strong>( mat4 <var>m</var>);</table><table><tr><td>dmat2 <strong>inverse</strong>( dmat2 <var>m</var>);</table><table><tr><td>dmat3 <strong>inverse</strong>( dmat3 <var>m</var>);</table><table><tr><td>dmat4 <strong>inverse</strong>( dmat4 <var>m</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> m </span> - Specifies the matrix of which to take the inverse.</dt></dl></div></div><div><h2>Description</h2><p>inverse returns the inverse of the matrix m. The values in the returned matrix are undefined if m is singular or poorly-conditioned (nearly singular).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>inverse (float)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>inverse (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#transpose><span><span>transpose</span></span></a>, <a href=#determinant><span><span>determinant</span></span></a></div></div>
<div id=inversesqrt><div></div><div><h2>Name</h2><p>inversesqrt — return the inverse of the square root of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>inversesqrt</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>inversesqrt</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of which to take the inverse of the square root.</dt></dl></div></div><div><h2>Description</h2><p>inversesqrt returns the inverse of the square root of $x$; i.e. the value $1 \over { \sqrt x }$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>inversesqrt (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>inversesqrt (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#pow><span><span>pow</span></span></a>, <a href=#sqrt><span><span>sqrt</span></span></a></div></div>
<div id=isinf><div></div><div><h2>Name</h2><p>isinf — determine whether the parameter is positive or negative infinity</div><div><h2>Declaration</h2><div><table><tr><td>genBType <strong>isinf</strong>(genType <var>x</var>);</table><table><tr><td>genBType <strong>isinf</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value to test for infinity.</dt></dl></div></div><div><h2>Description</h2><p>For each element <span>i</span> of the result, isinf returns true if x[<span>i</span>] is positive or negative floating point infinity and false otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>isinf (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>isinf (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#isnan><span><span>isnan</span></span></a></div></div>
<div id=isnan><div></div><div><h2>Name</h2><p>isnan — determine whether the parameter is a number</div><div><h2>Declaration</h2><div><table><tr><td>genBType <strong>isnan</strong>(genType <var>x</var>);</table><table><tr><td>genBType <strong>isnan</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value to test for NaN.</dt></dl></div></div><div><h2>Description</h2><p>For each element <span>i</span> of the result, isnan returns true if x[<span>i</span>] is positive or negative floating point NaN (Not a Number) and false otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>isnan (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>isnan (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#isinf><span><span>isinf</span></span></a></div></div>
<div id=ldexp><div></div><div><h2>Name</h2><p>ldexp — assemble a floating point number from a value and exponent</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>ldexp</strong>(genType <var>x</var>,<tr><td> genIType <var>exp</var>);</table><table><tr><td>genDType <strong>ldexp</strong>(genDType <var>x</var>,<tr><td> genIType <var>exp</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value to be used as a source of significand.<dt><span> out exp </span><dd><p>Specifies the value to be used as a source of exponent.</p></dl></div></div><div><h2>Description</h2><p>ldexp builds a floating point number from x and the corresponding integral exponent of two in exp, returning:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mi>significand</mml:mi> <mml:mo lspace=2px rspace=2px>⋅</mml:mo> <mml:msup> <mml:mn>2</mml:mn> <mml:mi>exponent</mml:mi> </mml:msup> </mml:math><p>If this product is too large to be represented in the floating point type, the result is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>ldexp (genType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>ldexp (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#frexp><span><span>frexp</span></span></a></div></div>
<div id=length><div></div><div><h2>Name</h2><p>length — calculate the length of a vector</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>length</strong>(genType <var>x</var>);</table><table><tr><td>double <strong>length</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies a vector of which to calculate the length.</dt></dl></div></div><div><h2>Description</h2><p>length returns the length of the vector, i.e. $\sqrt { { x[0] }^2 + { x[1] }^2 + \dots }$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>length (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>length (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#distance><span><span>distance</span></span></a>, <a href=#normalize><span><span>normalize</span></span></a></div></div>
<div id=lessThan><div></div><div><h2>Name</h2><p>lessThan — perform a component-wise less-than comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>lessThan</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>lessThan</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>lessThan</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>lessThan returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] < y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>lessThan (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThan (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThan (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=lessThanEqual><div></div><div><h2>Name</h2><p>lessThanEqual — perform a component-wise less-than-or-equal comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>lessThanEqual</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>lessThanEqual</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>lessThanEqual</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>lessThanEqual returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] ≤ y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>lessThanEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThanEqual (ivec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>lessThanEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#notEqual><span><span>notEqual</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=log><div></div><div><h2>Name</h2><p>log — return the natural logarithm of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>log</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of which to take the natural logarithm.</dt></dl></div></div><div><h2>Description</h2><p>log returns the natural logarithm of $x$, i.e. the value $y$ which satisfies $x = e^y$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>log (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=log2><div></div><div><h2>Name</h2><p>log2 — return the base 2 logarithm of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>log2</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of which to take the base 2 logarithm.</dt></dl></div></div><div><h2>Description</h2><p>log2 returns the base 2 logarithm of $x$, i.e. the value $y$ which satisfies $x = 2^y$. The result is undefined if $x \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>log2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#exp><span><span>exp</span></span></a>, <a href=#log><span><span>log</span></span></a>, <a href=#exp2><span><span>exp2</span></span></a></div></div>
<div id=matrixCompMult><div></div><div><h2>Name</h2><p>matrixCompMult — perform a component-wise multiplication of two matrices</div><div><h2>Declaration</h2><div><table><tr><td>mat <strong>matrixCompMult</strong>( mat <var>x</var>,<tr><td> mat <var>y</var>);</table><table><tr><td>dmat <strong>matrixCompMult</strong>( dmat <var>x</var>,<tr><td> dmat <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first matrix multiplicand.<dt><span> y </span><dd><p>Specifies the second matrix multiplicand.</p></dl></div></div><div><h2>Description</h2><p>matrixCompMult performs a component-wise multiplication of two matrices, yielding a result matrix where each component, result[i][j] is computed as the scalar product of x[i][j] and y[i][j].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>matrixCompMult (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>matrixCompMult (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#reflect><span><span>reflect</span></span></a></div></div>
<div id=max><div></div><div><h2>Name</h2><p>max — return the greater of two values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>max</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>);</table></div><div><table><tr><td>genType <strong>max</strong>(genType <var>x</var>,<tr><td> float <var>y</var>);</table></div><div><table><tr><td>genDType <strong>max</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>);</table></div><div><table><tr><td>genDType <strong>max</strong>(genDType <var>x</var>,<tr><td> double <var>y</var>);</table></div><div><table><tr><td>genIType <strong>max</strong>(genIType <var>x</var>,<tr><td> genIType <var>y</var>);</table></div><div><table><tr><td>genIType <strong>max</strong>(genIType <var>x</var>,<tr><td> int <var>y</var>);</table></div><div><table><tr><td>genUType <strong>max</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>);</table></div><div><table><tr><td>genUType <strong>max</strong>(genUType <var>x</var>,<tr><td> uint <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the first value to compare.<dt><span> y </span><dd><p>Specify the second value to compare.</p></dl></div></div><div><h2>Description</h2><p>max returns the maximum of the two parameters. It returns y if y is greater than x, otherwise it returns x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>max (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>max (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#abs><span><span>abs</span></span></a></div></div>
<div id=memoryBarrier><div></div><div><h2>Name</h2><p>memoryBarrier — controls the ordering of memory transactions issued by a single shader invocation</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>memoryBarrier</strong>( void);</table></div></div><div><h2>Description</h2><p>memoryBarrier waits on the completion of all memory accesses resulting from the use of image variables or atomic counters and then returns with no other effect. When this function returns, the results of any memory stores performed using coherent variables performed prior to the call will be visible to any future coherent memory access to the same addresses from other shader invocations. In particular, the values written this way in one shader stage are guaranteed to be visible to coherent memory accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>memoryBarrier<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#imageLoad><span><span>imageLoad</span></span></a>, <a href=#imageStore><span><span>imageStore</span></span></a>, <a href=#imageAtomicAdd><span><span>imageAtomicAdd</span></span></a>, <a href=#imageAtomicMin><span><span>imageAtomicMin</span></span></a>, <a href=#imageAtomicMax><span><span>imageAtomicMax</span></span></a>, <a href=#imageAtomicXor><span><span>imageAtomicXor</span></span></a>, <a href=#imageAtomicOr><span><span>imageAtomicOr</span></span></a>, <a href=#imageAtomicAnd><span><span>imageAtomicAnd</span></span></a>, <a href=#imageAtomicExchange><span><span>imageAtomicExchange</span></span></a>, <a href=#imageAtomicCompSwap><span><span>imageAtomicCompSwap</span></span></a>, <a href=#groupMemoryBarrier><span><span>groupMemoryBarrier</span></span></a>, <a href=#memoryBarrierImage><span><span>memoryBarrierImage</span></span></a>, <a href=#memoryBarrierBuffer><span><span>memoryBarrierBuffer</span></span></a>, <a href=#memoryBarrierShared><span><span>memoryBarrierShared</span></span></a></div></div>
<div id=memoryBarrierAtomicCounter><div></div><div><h2>Name</h2><p>memoryBarrierAtomicCounter — controls the ordering of operations on atomic counters issued by a single shader invocation</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>memoryBarrierAtomicCounter</strong>( void);</table></div></div><div><h2>Description</h2><p>memoryBarrierAtomicCounter waits on the completion of all accesses resulting from the use of atomic counters and then returns with no other effect. When this function returns, the results of any modifications to the value of atomic counters will be visible to any access to the same counter from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>memoryBarrierAtomicCounter<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#memoryBarrier><span><span>memoryBarrier</span></span></a></div></div>
<div id=memoryBarrierBuffer><div></div><div><h2>Name</h2><p>memoryBarrierBuffer — controls the ordering of operations on buffer variables issued by a single shader invocation</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>memoryBarrierBuffer</strong>( void);</table></div></div><div><h2>Description</h2><p>memoryBarrierBuffer waits on the completion of all memory accesses resulting from the use of buffer variables and then returns with no other effect. When this function returns, the results of any modifications to the content of buffer variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>memoryBarrierBuffer<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#memoryBarrier><span><span>memoryBarrier</span></span></a>, <a href=#memoryBarrierImage><span><span>memoryBarrierImage</span></span></a>, <a href=#memoryBarrierShared><span><span>memoryBarrierShared</span></span></a>, <a href=#groupMemoryBarrier><span><span>groupMemoryBarrier</span></span></a></div></div>
<div id=memoryBarrierImage><div></div><div><h2>Name</h2><p>memoryBarrierImage — controls the ordering of operations on image variables issued by a single shader invocation</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>memoryBarrierImage</strong>( void);</table></div></div><div><h2>Description</h2><p>memoryBarrierImage waits on the completion of all memory accesses resulting from the use of image variables and then returns with no other effect. When this function returns, the results of any modifications to the content of image variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>memoryBarrierImage<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#memoryBarrier><span><span>memoryBarrier</span></span></a>, <a href=#memoryBarrierShared><span><span>memoryBarrierShared</span></span></a>, <a href=#memoryBarrierBuffer><span><span>memoryBarrierBuffer</span></span></a>, <a href=#groupMemoryBarrier><span><span>groupMemoryBarrier</span></span></a></div></div>
<div id=memoryBarrierShared><div></div><div><h2>Name</h2><p>memoryBarrierShared — controls the ordering of operations on shared variables issued by a single shader invocation</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>memoryBarrierShared</strong>( void);</table></div></div><div><h2>Description</h2><p>memoryBarrierShared waits on the completion of all memory accesses resulting from the use of shared variables and then returns with no other effect. When this function returns, the results of any modifications to the content of shared variables will be visible to any access to the same buffer from other shader invocations. In particular, any modifications made in one shader stage are guaranteed to be visible to accesses performed by shader invocations in subsequent stages when those invocations were triggered by the execution of the original shader invocation (e.g., fragment shader invocations for a primitive resulting from a particular geometry shader invocation).<p>memoryBarrierShared is available only in the compute language.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>memoryBarrierShared<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#memoryBarrier><span><span>memoryBarrier</span></span></a>, <a href=#memoryBarrierImage><span><span>memoryBarrierImage</span></span></a>, <a href=#memoryBarrierBuffer><span><span>memoryBarrierBuffer</span></span></a>, <a href=#groupMemoryBarrier><span><span>groupMemoryBarrier</span></span></a></div></div>
<div id=min><div></div><div><h2>Name</h2><p>min — return the lesser of two values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>min</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>);</table></div><div><table><tr><td>genType <strong>min</strong>(genType <var>x</var>,<tr><td> float <var>y</var>);</table></div><div><table><tr><td>genDType <strong>min</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>);</table></div><div><table><tr><td>genDType <strong>min</strong>(genDType <var>x</var>,<tr><td> double <var>y</var>);</table></div><div><table><tr><td>genIType <strong>min</strong>(genIType <var>x</var>,<tr><td> genIType <var>y</var>);</table></div><div><table><tr><td>genIType <strong>min</strong>(genIType <var>x</var>,<tr><td> int <var>y</var>);</table></div><div><table><tr><td>genUType <strong>min</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>);</table></div><div><table><tr><td>genUType <strong>min</strong>(genUType <var>x</var>,<tr><td> uint <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the first value to compare.<dt><span> y </span><dd><p>Specify the second value to compare.</p></dl></div></div><div><h2>Description</h2><p>min returns the minimum of the two parameters. It returns y if y is less than x, otherwise it returns x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>min (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genIType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genUType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>min (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#max><span><span>max</span></span></a>, <a href=#abs><span><span>abs</span></span></a></div></div>
<div id=mix><div></div><div><h2>Name</h2><p>mix — linearly interpolate between two values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>mix</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>,<tr><td> genType <var>a</var>);</table></div><div><table><tr><td>genType <strong>mix</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>,<tr><td> float <var>a</var>);</table></div><div><table><tr><td>genDType <strong>mix</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>,<tr><td> genDType <var>a</var>);</table></div><div><table><tr><td>genDType <strong>mix</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>,<tr><td> double <var>a</var>);</table></div><div><table><tr><td>genType <strong>mix</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>,<tr><td> genBType <var>a</var>);</table></div><div><table><tr><td>genDType <strong>mix</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>,<tr><td> genBType <var>a</var>);</table></div><div><table><tr><td>genIType <strong>mix</strong>(genIType <var>x</var>,<tr><td> genIType <var>y</var>,<tr><td> genBType <var>a</var>);</table></div><div><table><tr><td>genUType <strong>mix</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>,<tr><td> genBType <var>a</var>);</table></div><div><table><tr><td>genBType <strong>mix</strong>(genBType <var>x</var>,<tr><td> genBType <var>y</var>,<tr><td> genBType <var>a</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the start of the range in which to interpolate.<dt><span> y </span><dd><p>Specify the end of the range in which to interpolate.</p><dt><span> a </span><dd><p>Specify the value to use to interpolate between x and y.</p></dl></div></div><div><h2>Description</h2><p>mix performs a linear interpolation between x and y using a to weight between them. The return value is computed as $x \times (1 - a) + y \times a$.<p>The variants of mix where a is genBType select which vector each returned component comes from. For a component of a that is false, the corresponding component of x is returned. For a component of a that is true, the corresponding component of y is returned. Components of x and y that are not selected are allowed to be invalid floating-point values and will have no effect on the results.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>mix(genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mix(genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mix(genIType), mix(genUType), mix(genBType)<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#min><span><span>min</span></span></a>, <a href=#max><span><span>max</span></span></a></div></div>
<div id=mod><div></div><div><h2>Name</h2><p>mod — compute value of one parameter modulo another</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>mod</strong>(genType <var>x</var>,<tr><td> float <var>y</var>);</table></div><div><table><tr><td>genType <strong>mod</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>);</table></div><div><table><tr><td>genDType <strong>mod</strong>(genDType <var>x</var>,<tr><td> double <var>y</var>);</table></div><div><table><tr><td>genDType <strong>mod</strong>(genDType <var>x</var>,<tr><td> genDType <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>mod returns the value of x modulo y. This is computed as x - y * <a href=#floor><span><span>floor</span></span></a>(x/y).</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>mod (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>mod (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#modf><span><span>modf</span></span></a>, <a href=#floor><span><span>floor</span></span></a></div></div>
<div id=modf><div></div><div><h2>Name</h2><p>modf — separate a value into its integer and fractional components</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>modf</strong>(genType <var>x</var>,<tr><td> out genType <var>i</var>);</table></div><div><table><tr><td>genDType <strong>modf</strong>(genDType <var>x</var>,<tr><td> out genDType <var>i</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to separate.<dt><span> out i </span><dd><p>A variable that receives the integer part of the argument.</p></dl></div></div><div><h2>Description</h2><p>modf separates a floating point value x into its integer and fractional parts. The fractional part of the number is returned from the function and the integer part (as a floating point quantity) is returned in the output parameter i.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>modf (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>modf (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#fract><span><span>fract</span></span></a>, <a href=#floor><span><span>floor</span></span></a></div></div>
<div id=noise><div></div><div><h2>Name</h2><p>noise — generate values with a pseudo-random noise function</div><div><h2>Declaration</h2><div><table><tr><td>float <strong>noise1</strong>(genType <var>x</var>);</table><table><tr><td>vec2 <strong>noise2</strong>(genType <var>x</var>);</table><table><tr><td>vec3 <strong>noise3</strong>(genType <var>x</var>);</table><table><tr><td>vec4 <strong>noise4</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the value to be used to seed the noise function.</dt></dl></div></div><div><h2>Description</h2><p>noise1, noise2, noise3 and noise4 return noise values (vector or scalar) based on the input value x. The noise function is a stochastic function that can be used to increase visual complexity. Values returned by the noise functions give the appearance of randomness, but are not truly random. They are defined to have the following characteristics:<p><div><ul><li><p>The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a Gaussian-like distribution.</p><li><p>The return value(s) have an overall average of 0.0.</p><li><p>They are repeatable, in that a particular input value will always produce the same return value.</p><li><p>They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character).</p><li><p>They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character).</p><li><p>They typically give different results under translation.</p><li><p>The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.</p><li><p>They are C1 continuous everywhere (i.e., the first derivative is continuous).</p></ul></div><p></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>noise1<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise2<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise3<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>noise4<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div></div>
<div id=normalize><div></div><div><h2>Name</h2><p>normalize — calculates the unit vector in the same direction as the original vector</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>normalize</strong>(genType <var>v</var>);</table><table><tr><td>genDType <strong>normalize</strong>(genDType <var>v</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> v </span> - Specifies the vector to normalize.</dt></dl></div></div><div><h2>Description</h2><p>normalize returns a vector with the same direction as its parameter, v, but with length 1.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>normalize (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>normalize (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#length><span><span>length</span></span></a></div></div>
<div id=not><div></div><div><h2>Name</h2><p>not — logically invert a boolean vector</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>not</strong>( bvec <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the vector to be inverted.</dt></dl></div></div><div><h2>Description</h2><p>not logically inverts the boolean vector x. It returns a new boolean vector for which each element <span>i</span> is computed as !x[i].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>not<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a></div></div>
<div id=notEqual><div></div><div><h2>Name</h2><p>notEqual — perform a component-wise not-equal-to comparison of two vectors</div><div><h2>Declaration</h2><div><table><tr><td>bvec <strong>notEqual</strong>( vec <var>x</var>,<tr><td> vec <var>y</var>);</table><table><tr><td>bvec <strong>notEqual</strong>( ivec <var>x</var>,<tr><td> ivec <var>y</var>);</table><table><tr><td>bvec <strong>notEqual</strong>( uvec <var>x</var>,<tr><td> uvec <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the comparison operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the comparison operation.</p></dl></div></div><div><h2>Description</h2><p>notEqual returns a boolean vector in which each element <span>i</span> is computed as x[<span>i</span>] != y[<span>i</span>].</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>notEqual (vec)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>notEqual (ivec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>notEqual (uvec)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#lessThan><span><span>lessThan</span></span></a>, <a href=#lessThanEqual><span><span>lessThanEqual</span></span></a>, <a href=#greaterThan><span><span>greaterThan</span></span></a>, <a href=#greaterThanEqual><span><span>greaterThanEqual</span></span></a>, <a href=#equal><span><span>equal</span></span></a>, <a href=#any><span><span>any</span></span></a>, <a href=#all><span><span>all</span></span></a>, <a href=#not><span><span>not</span></span></a></div></div>
<div id=outerProduct><div></div><div><h2>Name</h2><p>outerProduct — calculate the outer product of a pair of vectors</div><div><h2>Declaration</h2><div><table><tr><td>mat2 <strong>outerProduct</strong>( vec2 <var>c</var>,<tr><td> vec2 <var>r</var>);</table><table><tr><td>mat3 <strong>outerProduct</strong>( vec3 <var>c</var>,<tr><td> vec3 <var>r</var>);</table><table><tr><td>mat4 <strong>outerProduct</strong>( vec4 <var>c</var>,<tr><td> vec4 <var>r</var>);</table><table><tr><td>mat2x3 <strong>outerProduct</strong>( vec3 <var>c</var>,<tr><td> vec2 <var>r</var>);</table><table><tr><td>mat3x2 <strong>outerProduct</strong>( vec2 <var>c</var>,<tr><td> vec3 <var>r</var>);</table><table><tr><td>mat2x4 <strong>outerProduct</strong>( vec4 <var>c</var>,<tr><td> vec2 <var>r</var>);</table><table><tr><td>mat4x2 <strong>outerProduct</strong>( vec2 <var>c</var>,<tr><td> vec4 <var>r</var>);</table><table><tr><td>mat3x4 <strong>outerProduct</strong>( vec4 <var>c</var>,<tr><td> vec3 <var>r</var>);</table><table><tr><td>mat4x3 <strong>outerProduct</strong>( vec3 <var>c</var>,<tr><td> vec4 <var>r</var>);</table><table><tr><td>dmat2 <strong>outerProduct</strong>( dvec2 <var>c</var>,<tr><td> dvec2 <var>r</var>);</table><table><tr><td>dmat3 <strong>outerProduct</strong>( dvec3 <var>c</var>,<tr><td> dvec3 <var>r</var>);</table><table><tr><td>dmat4 <strong>outerProduct</strong>( dvec4 <var>c</var>,<tr><td> dvec4 <var>r</var>);</table><table><tr><td>dmat2x3 <strong>outerProduct</strong>( dvec3 <var>c</var>,<tr><td> dvec2 <var>r</var>);</table><table><tr><td>dmat3x2 <strong>outerProduct</strong>( dvec2 <var>c</var>,<tr><td> dvec3 <var>r</var>);</table><table><tr><td>dmat2x4 <strong>outerProduct</strong>( dvec4 <var>c</var>,<tr><td> dvec2 <var>r</var>);</table><table><tr><td>dmat4x2 <strong>outerProduct</strong>( dvec2 <var>c</var>,<tr><td> dvec4 <var>r</var>);</table><table><tr><td>dmat3x4 <strong>outerProduct</strong>( dvec4 <var>c</var>,<tr><td> dvec3 <var>r</var>);</table><table><tr><td>dmat4x3 <strong>outerProduct</strong>( dvec3 <var>c</var>,<tr><td> dvec4 <var>r</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> c </span> - Specifies the parameter to be treated as a column vector.<dt><span> r </span><dd><p>Specifies the parameter to be treated as a row vector.</p></dl></div></div><div><h2>Description</h2><p>outerProduct treats the first parameter c as a column vector (matrix with one column) and the second parameter r as a row vector (matrix with one row) and does a linear algebraic matrix multiply c * r, yielding a matrix whose number of rows is the number of components in c and whose number of columns is the number of components in r.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>outerProduct (float)<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>outerProduct (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a></div></div>
<div id=packDouble2x32><div></div><div><h2>Name</h2><p>packDouble2x32 — create a double-precision value from a pair of unsigned integers</div><div><h2>Declaration</h2><div><table><tr><td>double <strong>packDouble2x32</strong>( uvec2 <var>v</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> v </span> - Specifies a vector of two unsigned integers to be packed into a single double-precision result.</dt></dl></div></div><div><h2>Description</h2><p>packDouble2x32 packs the component of parameter v into a 64-bit value. If an IEEE-754 infinity or NaN is created, it will not signal and the resulting floating-point value is undefined. Otherwise, the bit-level representation of v is preserved. The first vector component (v[0]) specifies the 32 least significant bits of the result; the second component (v[1]) specifies the 32 most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packDouble2x32<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a></div></div>
<div id=packHalf2x16><div></div><div><h2>Name</h2><p>packHalf2x16 — convert two 32-bit floating-point quantities to 16-bit quantities and pack them into a single 32-bit integer</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>packHalf2x16</strong>( vec2 <var>v</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> v </span> - Specify a vector of two 32-bit floating point values that are to be converted to 16-bit representation and packed into the result.</dt></dl></div></div><div><h2>Description</h2><p>packHalf2x16 returns an unsigned integer obtained by converting the components of a two-component floating-point vector to the 16-bit floating-point representation found in the OpenGL Specification, and then packing these two 16-bit integers into a 32-bit unsigned integer. The first vector component specifies the 16 least-significant bits of the result; the second component specifies the 16 most-significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packHalf2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a>, <a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a>, <a href=#unpackHalf2x16><span><span>unpackHalf2x16</span></span></a></div></div>
<div id=packUnorm><div></div><div><h2>Name</h2><p>packUnorm — pack floating-point values into an unsigned integer</div><div><h2>Declaration</h2><div><table><tr><td>uint <strong>packUnorm2x16</strong>( vec2 <var>v</var>);</table><table><tr><td>uint <strong>packSnorm2x16</strong>( vec2 <var>v</var>);</table><table><tr><td>uint <strong>packUnorm4x8</strong>( vec4 <var>v</var>);</table><table><tr><td>uint <strong>packSnorm4x8</strong>( vec4 <var>v</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> v </span> - Specifies a vector of values to be packed into an unsigned integer.</dt></dl></div></div><div><h2>Description</h2><p>packUnorm2x16, packSnorm2x16, packUnorm4x8 and packSnorm4x8 convert each component of the normalized floating-ponit value v into 8- or 16-bit integer values and then packs the results into a 32-bit unsigned intgeter.<p>The conversion for component c of v to fixed-point is performed as follows:<div><ul><li><p>packUnorm2x16: round(clamp(c, 0.0, 1.0) * 65535.0)</p><li><p>packSnorm2x16: round(clamp(c, -1.0, 1.0) * 32767.0)</p><li><p>packUnorm4x8: round(clamp(c, 0.0, 1.0) * 255.0)</p><li><p>packSnorm4x8: round(clamp(c, -1.0, 1.0) * 127.0)</p></ul></div><p><p>The first component of the vector will be written to the least significant bits of the output; the last component will be written to the most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>packUnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>packSnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>packUnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>packSnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p>unpackUnorm2x16, unpackSnorm2x16, unpackUnorm4x8, unpackSnorm4x8</div></div>
<div id=pow><div></div><div><h2>Name</h2><p>pow — return the value of the first parameter raised to the power of the second</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>pow</strong>(genType <var>x</var>,<tr><td> genType <var>y</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to raise to the power - .<dt><span> y </span><dd><p>Specify the power to which to raise x.</p></dl></div></div><div><h2>Description</h2><p>pow returns the value of $x$ raised to the $y$ power, i.e. $x^y$. The result is undefined if $x < 0$ or if $x = 0$ and $y \leq 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>pow<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=radians><div></div><div><h2>Name</h2><p>radians — convert a quantity in degrees to radians</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>radians</strong>(genType <var>degrees</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> degrees </span> - Specify the quantity, in degrees, to be converted to radians.</dt></dl></div></div><div><h2>Description</h2><p>radians converts a quantity specified in degrees into radians. The return value is ${ \pi \times degrees } \over 180$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>radians<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#degrees><span><span>degrees</span></span></a>,</div></div>
<div id=reflect><div></div><div><h2>Name</h2><p>reflect — calculate the reflection direction for an incident vector</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>reflect</strong>(genType <var>I</var>,<tr><td> genType <var>N</var>);</table><table><tr><td>genDType <strong>reflect</strong>(genDType <var>I</var>,<tr><td> genDType <var>N</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> I </span> - Specifies the incident vector.<dt><span> N </span><dd><p>Specifies the normal vector.</p></dl></div></div><div><h2>Description</h2><p>For a given incident vector I and surface normal N reflect returns the reflection direction calculated as I - 2.0 * dot(N, I) * N.<p>N should be normalized in order to achieve the desired result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>reflect (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>reflect (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#refract><span><span>refract</span></span></a></div></div>
<div id=refract><div></div><div><h2>Name</h2><p>refract — calculate the refraction direction for an incident vector</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>refract</strong>(genType <var>I</var>,<tr><td> genType <var>N</var>,<tr><td> float <var>eta</var>);</table><table><tr><td>genDType <strong>refract</strong>(genDType <var>I</var>,<tr><td> genDType <var>N</var>,<tr><td> float <var>eta</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> I </span> - Specifies the incident vector.<dt><span> N </span><dd><p>Specifies the normal vector.</p><dt><span> eta </span><dd><p>Specifies the ratio of indices of refraction.</p></dl></div></div><div><h2>Description</h2><p>For a given incident vector I, surface normal N and ratio of indices of refraction, eta, refract returns the refraction vector, R.<p>R is calculated as:<p><pre>    k = 1.0 - eta * eta * (1.0 - dot(N, I) * dot(N, I));
    if (k < 0.0)
        R = genType(0.0);       // or genDType(0.0)
    else
        R = eta * I - (eta * dot(N, I) + sqrt(k)) * N;</pre><p><p>The input parameters I and N should be normalized in order to achieve the desired result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>refract (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>refract (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#dot><span><span>dot</span></span></a>, <a href=#reflect><span><span>reflect</span></span></a></div></div>
<div id=removedTypes><div></div><div><h2>Name</h2><p>removedTypes — Describes types removed and replaced in the OpenGL API in OpenGL 4.2</div><div><h2>Description</h2><p>In the May, 2012 update of the OpenGL 4.2 Specification, all APIs using the types GLclampf and GLclampd were modified to use GLfloat and GLdouble, respectively, instead. Language was added to the Specification requiring that these parameters be clamped, when required, at use time rather than at specification time.<p>This change allows specifying parameters in ranges appropriate for non-fixed-point framebuffers (integer and floating-point formats). The change does not require any changes to user code calling these functions, because the actual underlying types are identical, the behavior is externally unchanged, and the header files continue to define the old types for compatibility with older code.</div><div><h2>See Also</h2><p><a href=#glBlendColor><span><span>glBlendColor</span></span></a>, <a href=#glClearColor><span><span>glClearColor</span></span></a>, <a href=#glClearDepth><span><span>glClearDepth</span></span></a>, <a href=#glDepthRange><span><span>glDepthRange</span></span></a>, <a href=#glDepthRangeArray><span><span>glDepthRangeArray</span></span></a>, <a href=#glDepthRangeIndexed><span><span>glDepthRangeIndexed</span></span></a>, <a href=#glMinSampleShading><span><span>glMinSampleShading</span></span></a>, <a href=#glSampleCoverage><span><span>glSampleCoverage</span></span></a></div></div>
<div id=round><div></div><div><h2>Name</h2><p>round — find the nearest integer to the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>round</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>round</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>round returns a value equal to the nearest integer to x. The fraction 0.5 will round in a direction chosen by the implementation, presumably the direction that is fastest. This includes the possibility that round(x) returns the same value as <a href=#roundEven><span><span>roundEven</span></span></a>(x) for all values of x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>round (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>round (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#roundEven><span><span>roundEven</span></span></a></div></div>
<div id=roundEven><div></div><div><h2>Name</h2><p>roundEven — find the nearest even integer to the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>roundEven</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>roundEven</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>roundEven returns a value equal to the nearest integer to x. The fractional part of 0.5 will round toward the nearest even integer. For example, both 3.5 and 4.5 will round to 4.0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>roundEven (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>roundEven (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=sign><div></div><div><h2>Name</h2><p>sign — extract the sign of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>sign</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genIType <strong>sign</strong>(genIType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>sign</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value from which to extract the sign.</dt></dl></div></div><div><h2>Description</h2><p>sign returns -1.0 if x is less than 0.0, 0.0 if x is equal to 0.0, and +1.0 if x is greater than 0.0.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sign (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sign (genIType)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sign (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#abs><span><span>abs</span></span></a></div></div>
<div id=sin><div></div><div><h2>Name</h2><p>sin — return the sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>sin</strong>(genType <var>angle</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> angle </span> - Specify the quantity, in radians, of which to return the sine.</dt></dl></div></div><div><h2>Description</h2><p>sin returns the trigonometric sine of angle.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sin<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#cos><span><span>cos</span></span></a>,</div></div>
<div id=sinh><div></div><div><h2>Name</h2><p>sinh — return the hyperbolic sine of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>sinh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose hyperbolic sine to return.</dt></dl></div></div><div><h2>Description</h2><p>sinh returns the hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic sine of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:msup> <mml:mi>e</mml:mi> <mml:mi>x</mml:mi> </mml:msup> <mml:mo>−</mml:mo> <mml:msup> <mml:mi>e</mml:mi> <mml:mrow> <mml:mo>−</mml:mo> <mml:mi>x</mml:mi> </mml:mrow> </mml:msup> </mml:mrow> <mml:mn>2</mml:mn> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sinh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=smoothstep><div></div><div><h2>Name</h2><p>smoothstep — perform Hermite interpolation between two values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>smoothstep</strong>(genType <var>edge0</var>,<tr><td> genType <var>edge1</var>,<tr><td> genType <var>x</var>);</table></div><div><table><tr><td>genType <strong>smoothstep</strong>( float <var>edge0</var>,<tr><td> float <var>edge1</var>,<tr><td> genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>smoothstep</strong>(genDType <var>edge0</var>,<tr><td> genDType <var>edge1</var>,<tr><td> genDType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>smoothstep</strong>( double <var>edge0</var>,<tr><td> double <var>edge1</var>,<tr><td> genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> edge0 </span> - Specifies the value of the lower edge of the Hermite function.<dt><span> edge1 </span><dd><p>Specifies the value of the upper edge of the Hermite function.</p><dt><span> x </span><dd><p>Specifies the source value for interpolation.</p></dl></div></div><div><h2>Description</h2><p>smoothstep performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where a threshold function with a smooth transition is desired. smoothstep is equivalent to:<p><pre>    genType t;  /* Or genDType t; */
    t = clamp((x - edge0) / (edge1 - edge0), 0.0, 1.0);
    return t * t * (3.0 - 2.0 * t);</pre><p><p>Results are undefined if edge0 ≥ edge1.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>smoothstep (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>smoothstep (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#mix><span><span>mix</span></span></a>, <a href=#step><span><span>step</span></span></a></div></div>
<div id=sqrt><div></div><div><h2>Name</h2><p>sqrt — return the square root of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>sqrt</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>sqrt</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value of which to take the square root.</dt></dl></div></div><div><h2>Description</h2><p>sqrt returns the square root of $x$, i.e. the value $\sqrt { x }$. The result is undefined if $x < 0$.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>sqrt (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>sqrt (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#pow><span><span>pow</span></span></a>, <a href=#inversesqrt><span><span>inversesqrt</span></span></a></div></div>
<div id=step><div></div><div><h2>Name</h2><p>step — generate a step function by comparing two values</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>step</strong>(genType <var>edge</var>,<tr><td> genType <var>x</var>);</table></div><div><table><tr><td>genType <strong>step</strong>( float <var>edge</var>,<tr><td> genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>step</strong>(genDType <var>edge</var>,<tr><td> genDType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>step</strong>( double <var>edge</var>,<tr><td> genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> edge </span> - Specifies the location of the edge of the step function.<dt><span> x </span><dd><p>Specify the value to be used to generate the step function.</p></dl></div></div><div><h2>Description</h2><p>step generates a step function by comparing x to edge.<p>For element <span>i</span> of the return value, 0.0 is returned if x[<span>i</span>] < edge[<span>i</span>], and 1.0 is returned otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>step (genType)<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>step (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#mix><span><span>mix</span></span></a>, <a href=#smoothstep><span><span>smoothstep</span></span></a></div></div>
<div id=tan><div></div><div><h2>Name</h2><p>tan — return the tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>tan</strong>(genType <var>angle</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> angle </span> - Specify the quantity, in radians, of which to return the tangent.</dt></dl></div></div><div><h2>Description</h2><p>tan returns the trigonometric tangent of angle.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>tan<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#atan><span><span>atan</span></span></a></div></div>
<div id=tanh><div></div><div><h2>Name</h2><p>tanh — return the hyperbolic tangent of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>tanh</strong>(genType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value whose hyperbolic tangent to return.</dt></dl></div></div><div><h2>Description</h2><p>tanh returns the hyperbolic tangent of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math>. The hyperbolic tangent of <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:mi mathvariant=italic>x</mml:mi></mml:math> is computed as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi mathvariant=italic>sinh</mml:mi> <mml:mo>⁡</mml:mo> <mml:mfenced close=) open=(> <mml:mi>x</mml:mi> </mml:mfenced> </mml:mrow> <mml:mrow> <mml:mi mathvariant=italic>cosh</mml:mi> <mml:mo>⁡</mml:mo> <mml:mfenced close=) open=(> <mml:mi>x</mml:mi> </mml:mfenced> </mml:mrow> </mml:mfrac> </mml:mrow> </mml:math>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>tanh<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#sin><span><span>sin</span></span></a>, <a href=#cos><span><span>cos</span></span></a>, <a href=#sinh><span><span>sinh</span></span></a>, <a href=#cosh><span><span>cosh</span></span></a></div></div>
<div id=texelFetch><div></div><div><h2>Name</h2><p>texelFetch — perform a lookup of a single texel within a texture</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler1D <var>sampler</var>,<tr><td> int <var>P</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler2D <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler3D <var>sampler</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler2DRect <var>sampler</var>,<tr><td> ivec2 <var>P</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler1DArray <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler2DArray <var>sampler</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsamplerBuffer <var>sampler</var>,<tr><td> int <var>P</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler2DMS <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>sample</var>);</table><table><tr><td>gvec4 <strong>texelFetch</strong>( gsampler2DMSArray <var>sampler</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>sample</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> lod </span><dd><p>If present, specifies the level-of-detail within the texture from which the texel will be fetched.</p><dt><span> sample </span><dd><p>For multisampled fetches, specifies which sample within the texel from which will be returned.</p></dl></div></div><div><h2>Description</h2><p>texelFetch performs a lookup of a single texel from texture coordinate P in the texture bound to sampler. The array layer is specified in the last component of P for array forms. The lod parameter (if present) specifies the level-of-detail from which the texel will be fetched. The sample specifies which sample within the texel will be returned when reading from a multi-sample texure.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texelFetch<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetch (gsampler2DRect, gsamplerBuffer)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetch (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=texelFetchOffset><div></div><div><h2>Name</h2><p>texelFetchOffset — perform a lookup of a single texel within a texture with an offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> int <var>P</var>,<tr><td> int <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>lod</var>,<tr><td> ivec3 <var>offset</var>);</table><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler1DArray <var>sampler</var>,<tr><td> ivec2 <var>P</var>,<tr><td> int <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>texelFetchOffset</strong>( gsampler2DArray <var>sampler</var>,<tr><td> ivec3 <var>P</var>,<tr><td> int <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> lod </span><dd><p>If present, specifies the level-of-detail within the texture from which the texel will be fetched.</p><dt><span> offset </span><dd><p>Specifies offset, in texels that will be applied to P before looking up the texel.</p></dl></div></div><div><h2>Description</h2><p>texelFetchOffset performs a lookup of a single texel from texture coordinate P in the texture bound to sampler. Before fetching the texel, the offset specified in offset is added to P. offset must be a constant expression. The array layer is specified in the last component of P for array forms. The lod parameter (if present) specifies the level-of-detail from which the texel will be fetched. The sample parameter specifies which sample within the texel will be returned when reading from a multi-sample texure.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texelFetchOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetchOffset (gsampler2DRect)<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texelFetchOffset (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=texture><div></div><div><h2>Name</h2><p>texture — retrieves texels from a texture</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>texture</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsamplerCube <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>texture</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>texture</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>texture</strong>( samplerCubeShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsamplerCubeArray <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>texture</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>texture</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>texture</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec2 <var>P</var>);</table><table><tr><td>float <strong>texture</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>float <strong>texture</strong>( samplerCubeArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>compare</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> bias </span><dd><p>Specifies an optional bias to be applied during level-of-detail computation.</p><dt><span> compare </span><dd><p>Specifies the value to which the fetched texel will be compared when sampling from samplerCubeArrayShadow.</p></dl></div></div><div><h2>Description</h2><p>texture samples texels from the texture bound to sampler at texture coordinate P. An optional bias, specified in bias is included in the level-of-detail computation that is used to choose mipmap(s) from which to sample.<p>For <span>shadow</span> forms, when compare is present, it is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>sub</mml:mi></mml:msub></mml:math> and the array layer is specified in P.w. When compare is not present, the last component of P is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>sub</mml:mi></mml:msub></mml:math> and the array layer is specified in the second to last component of P. (The second component of P is unused for <span>1D</span> shadow lookups.)<p>For non-shadow variants, the array layer comes from the last component of P.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>texture<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsampler2DMS, gsampler2DMSArray)<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>texture (gsamplerCubeArray{Shadow})<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGather><div></div><div><h2>Name</h2><p>textureGather — gathers four texels from a texture</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureGather</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGather</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGather</strong>( gsamplerCube <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGather</strong>( gsamplerCubeArray <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGather</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>vec4 <strong>textureGather</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>);</table><table><tr><td>vec4 <strong>textureGather</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>refZ</var>);</table><table><tr><td>vec4 <strong>textureGather</strong>( samplerCubeShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>refZ</var>);</table><table><tr><td>vec4 <strong>textureGather</strong>( samplerCubeArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>refZ</var>);</table><table><tr><td>vec4 <strong>textureGather</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> comp </span><dd><p>Specifies the component of the source texture that will be used to generate the resulting vector.</p><dt><span> refZ </span><dd><p>Specifies the reference Z value used in the comparison for shadow forms.</p></dl></div></div><div><h2>Description</h2><p>textureGather returns the value:<p><pre>    vec4(Sample_i0_j1(P, base).comp,
         Sample_i1_j1(P, base).comp,
         Sample_i1_j0(P, base).comp,
         Sample_i0_j0(P, base).comp);</pre><p><p>If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGather<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGatherOffset><div></div><div><h2>Name</h2><p>textureGatherOffset — gathers four texels from a texture with offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureGatherOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGatherOffset</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGatherOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>vec4 <strong>textureGatherOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>vec4 <strong>textureGatherOffset</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>vec4 <strong>textureGatherOffset</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> comp </span><dd><p>Specifies the component of the source texture that will be used to generate the resulting vector.</p><dt><span> refZ </span><dd><p>Specifies the reference Z value used in the comparison for shadow forms.</p><dt><span> offset </span><dd><p>Specifies the offset from the specified texture coordinate P from which the texels will be gathered.</p></dl></div></div><div><h2>Description</h2><p>textureGatherOffset returns the value:<p><pre>    vec4(Sample_i0_j1(P + offset, base).comp,
         Sample_i1_j1(P + offset, base).comp,
         Sample_i1_j0(P + offset, base).comp,
         Sample_i0_j0(P + offset, base).comp);</pre><p><p>It perfoms as <a href=#textureGather><span><span>textureGather</span></span></a> but with offset applied as described in <a href=#textureOffset><span><span>textureOffset</span></span></a>, except that the implementation-dependent minimum and maximum offset values are given by GL_MIN_PROGRRAM_TEXTURE_GATHER_OFFSET and GL_MAX_PROGRAM_TEXTURE_GATHER_OFFSET, respectively.<p>If specified, the value of comp must be a constant integer expression with a value of 0, 1, 2, or 3, identifying the x, y, z or w component of the four-component vector lookup result for each texel, respectively. If comp is not specified, it is treated as 0, selecting the x component of each texel to generate the result.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGatherOffset<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGatherOffsets><div></div><div><h2>Name</h2><p>textureGatherOffsets — gathers four texels from a texture with an array of offsets</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureGatherOffsets</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> ivec2 <var>offsets[4]</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGatherOffsets</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offsets[4]</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>gvec4 <strong>textureGatherOffsets</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offsets[4]</var>,<tr><td> [int <var>comp]</var>);</table><table><tr><td>vec4 <strong>textureGatherOffsets</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offsets[4]</var>);</table><table><tr><td>vec4 <strong>textureGatherOffsets</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offsets[4]</var>);</table><table><tr><td>vec4 <strong>textureGatherOffsets</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>refZ</var>,<tr><td> ivec2 <var>offsets[4]</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> comp </span><dd><p>Specifies the component of the source texture that will be used to generate the resulting vector.</p><dt><span> refZ </span><dd><p>Specifies the reference Z value used in the comparison for shadow forms.</p><dt><span> offsets </span><dd><p>Specifies an array of offsets from the specified texture coordinate P from which the texels will be gathered.</p></dl></div></div><div><h2>Description</h2><p>textureGatherOffsets operates identically to <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, except that offsets is used to determine the location of the four texels to sample. Each of the four texels is obtained by applying the offset in offsets as a (u, v) coordinate offset to P, identifying the four-texel GL_LINEAR footprint, and then selecting the texel <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub><mml:msub><mml:mi>i</mml:mi><mml:mn>0</mml:mn></mml:msub></mml:math> of that footprint. The specified values in offsets must be set with constant integral expressions.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGatherOffsets<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGrad><div></div><div><h2>Name</h2><p>textureGrad — perform a texture lookup with explicit gradients</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsamplerCube <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( samplerCubeShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>);</table><table><tr><td>float <strong>textureGrad</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>);</table><table><tr><td>gvec4 <strong>textureGrad</strong>( gsamplerCubeArray <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> dPdx </span><dd><p>Specifies the partial derivative of P with respect to window x.</p><dt><span> dPdy </span><dd><p>Specifies the partial derivative of P with respect to window y.</p></dl></div></div><div><h2>Description</h2><p>textureGrad performs a texture lookup at coordinate P from the texture bound to sampler with explicit texture coordinate gradiends as specified in dPdx and dPdy. Set:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δs</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mfrac> <mml:mi>δP</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi>  for a 1D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.s</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi>  otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δs</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mfrac> <mml:mi>δP</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi>  for a 1D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.s</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi>  otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δt</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi>  for a 1D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.t</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi> otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δt</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi>  for a 1D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.t</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi>  otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δr</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi>  for a 1D or 2D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.p</mml:mi> <mml:mi>δx</mml:mi> </mml:mfrac> <mml:mi>  otherwise</mml:mi> </mml:math><p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mfrac> <mml:mi>δr</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0.0</mml:mn> <mml:mi>  for a 1D or 2D texture,  </mml:mi> <mml:mfrac> <mml:mi>δP.p</mml:mi> <mml:mi>δy</mml:mi> </mml:mfrac> <mml:mi>  otherwise</mml:mi> </mml:math><p>For the cube version, the partial derivatives of P are assumed to be in the coordinate system used before texture coordinates are projected onto the appropriate cube face.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGrad<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGrad (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGrad (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureGradOffset><div></div><div><h2>Name</h2><p>textureGradOffset — perform a texture lookup with explicit gradients and offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>,<tr><td> ivec3 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureGradOffset</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureGradOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureGradOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureGradOffset</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureGradOffset</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureGradOffset</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> dPdx </span><dd><p>Specifies the partial derivative of P with respect to window x.</p><dt><span> dPdy </span><dd><p>Specifies the partial derivative of P with respect to window y.</p><dt><span> offset </span><dd><p>Specifies the offset to be applied to the texture coordinates before sampling.</p></dl></div></div><div><h2>Description</h2><p>textureGradOffset performs a texture lookup at coordinate P from the texture bound to sampler with explicit texture coordinate gradiends as specified in dPdx and dPdy. An explicit offset is also supplied in offset. textureGradOffset consumes dPdx and dPdy as <a href=#textureGrad><span><span>textureGrad</span></span></a> and offset as <a href=#textureOffset><span><span>textureOffset</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureGradOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureGradOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureLod><div></div><div><h2>Name</h2><p>textureLod — perform a texture lookup with explicit level-of-detail</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureLod</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsamplerCube <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>float <strong>textureLod</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>float <strong>textureLod</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>float <strong>textureLod</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureLod</strong>( gsamplerCubeArray <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> lod </span><dd><p>Specifies the explicit level-of-detail</p></dl></div></div><div><h2>Description</h2><p>textureLod performs a texture lookup at coordinate P from the texture bound to sampler with an explicit level-of-detail as specified in lod. lod specifies <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>λ</mml:mi><mml:mi>base</mml:mi></mml:msub></mml:math> and sets the partial derivatives as follows:<p><mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML> <mml:mtable rowalign=center> <mml:mtr> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>u</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>v</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>w</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>x</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> </mml:mrow> </mml:mtd> </mml:mtr> <mml:mtr> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>u</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>v</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> <mml:mo>,</mml:mo> </mml:mrow> </mml:mtd> <mml:mtd> <mml:mrow> <mml:mfrac> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>w</mml:mi> </mml:mrow> <mml:mrow> <mml:mi>δ</mml:mi> <mml:mi>y</mml:mi> </mml:mrow> </mml:mfrac> <mml:mo>=</mml:mo> <mml:mn>0</mml:mn> </mml:mrow> </mml:mtd> </mml:mtr> </mml:mtable> </mml:math></div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureLod<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLod (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLod (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureLodOffset><div></div><div><h2>Name</h2><p>textureLodOffset — perform a texture lookup with explicit level-of-detail and offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureLodOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureLodOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureLodOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec3 <var>offset</var>);</table><table><tr><td>float <strong>textureLodOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureLodOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureLodOffset</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureLodOffset</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureLodOffset</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which the texture will be sampled.</p><dt><span> lod </span><dd><p>Specifies the explicit level-of-detail from which texels will be fetched.</p><dt><span> offset </span><dd><p>Specifies the offset that will be applied to P before texels are fetched.</p></dl></div></div><div><h2>Description</h2><p>textureLodOffset performs a texture lookup at coordinate P from the texture bound to sampler with an explicit level-of-detail as specified in lod. Behavior is the same as in <a href=#textureLod><span><span>textureLod</span></span></a> except that before sampling, offset is added to P.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureLodOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLodOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureLodOffset (gsamplerCubeArray)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureOffset><div></div><div><h2>Name</h2><p>textureOffset — perform a texture lookup with offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec3 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureOffset</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler1DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureOffset</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureOffset</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureOffset</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> offset </span><dd><p>Specifies offset, in texels that will be applied to P before looking up the texel.</p></dl></div></div><div><h2>Description</h2><p>textureOffset performs a texture lookup at coordinate P from the texture bound to sampler with an additional offset, specified in texels in offset that will be applied to the (u, v, w) texture coordinates before looking up each texel. The offset value must be a constant expression. A limited range of offset values are supported; the minimum and maximum offset values are implementation-dependent and may be determined by querying GL_MIN_PROGRAM_TEXEL_OFFSET and GL_MAX_PROGRAM_TEXEL_OFFSET, respectively.<p>Note that offset does not apply to the layer coordinate for texture arrays. Also note that offsets are not supported for cube maps.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProj><div></div><div><h2>Name</h2><p>textureProj — perform a texture lookup with projection</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureProj</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureProj</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>gvec4 <strong>textureProj</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec4 <var>P</var>);</table><table><tr><td>float <strong>textureProj</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> bias </span><dd><p>Specifies an optional bias to be applied during level-of-detail computation.</p></dl></div></div><div><h2>Description</h2><p>textureProj performs a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#texture><span><span>texture</span></span></a>.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProj<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProj (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjGrad><div></div><div><h2>Name</h2><p>textureProjGrad — perform a texture lookup with projection and explicit gradients</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>pDx</var>,<tr><td> float <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>pDx</var>,<tr><td> float <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec3 <var>pDx</var>,<tr><td> vec3 <var>pDy</var>);</table><table><tr><td>float <strong>textureProjGrad</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>pDx</var>,<tr><td> float <var>pDy</var>);</table><table><tr><td>float <strong>textureProjGrad</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table><table><tr><td>gvec4 <strong>textureProjGrad</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table><table><tr><td>float <strong>textureProjGrad</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>pDx</var>,<tr><td> vec2 <var>pDy</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> dPdx </span><dd><p>Specifies the partial derivative of P with respect to window x.</p><dt><span> dPdy </span><dd><p>Specifies the partial derivative of P with respect to window y.</p></dl></div></div><div><h2>Description</h2><p>textureProjGrad performs a texture lookup with projection and explicit gradients. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureGrad><span><span>textureGrad</span></span></a>, passing dPdx and dPdy as gradients.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjGrad<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjGrad (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjGradOffset><div></div><div><h2>Name</h2><p>textureProjGradOffset — perform a texture lookup with projection, explicit gradients and offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec3 <var>dPdx</var>,<tr><td> vec3 <var>dPdy</var>,<tr><td> ivec3 <var>offset</var>);</table><table><tr><td>float <strong>textureProjGradOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>dPdx</var>,<tr><td> float <var>dPdy</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureProjGradOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjGradOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureProjGradOffset</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> vec2 <var>dPdx</var>,<tr><td> vec2 <var>dPdy</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> dPdx </span><dd><p>Specifies the partial derivative of P with respect to window x.</p><dt><span> dPdy </span><dd><p>Specifies the partial derivative of P with respect to window y.</p><dt><span> offset </span><dd><p>Specifies the offsets, in texels at which the texture will be sampled relative to the projection of P.</p></dl></div></div><div><h2>Description</h2><p>textureProjGradOffset performs a texture lookup with projection and explicit gradients and offsets. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, passing dPdx and dPdy as gradients, and offset as the offset.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjGradOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjGradOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjLod><div></div><div><h2>Name</h2><p>textureProjLod — perform a texture lookup with projection and explicit level-of-detail</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProjLod</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureProjLod</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureProjLod</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureProjLod</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>gvec4 <strong>textureProjLod</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>float <strong>textureProjLod</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table><table><tr><td>float <strong>textureProjLod</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> lod </span><dd><p>Specifies the explicit level-of-detail from which to fetch texels.</p></dl></div></div><div><h2>Description</h2><p>textureProjLod performs a texture lookup with projection from an explicitly specified level-of-detail. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureLod><span><span>textureLod</span></span></a>, with lod used to specify the level-of-detail from which the texture will be sampled.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjLod<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjLodOffset><div></div><div><h2>Name</h2><p>textureProjLodOffset — perform a texture lookup with projection and explicit level-of-detail and offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProjLodOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjLodOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjLodOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjLodOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjLodOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec3 <var>offset</var>);</table><table><tr><td>float <strong>textureProjLodOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> int <var>offset</var>);</table><table><tr><td>float <strong>textureProjLodOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> float <var>lod</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which texture will be sampled.</p><dt><span> lod </span><dd><p>Specifies the explicit level-of-detail from which to fetch texels.</p><dt><span> offset </span><dd><p>Specifies the offset, in texels, to be applied to P before fetching texels.</p></dl></div></div><div><h2>Description</h2><p>textureProjLodOffset performs a texture lookup with projection from an explicitly specified level-of-detail with an offset applied to the texture coordinates before sampling. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, with lod used to specify the level-of-detail from which the texture will be sampled and offset used to specifiy the offset, in texels, to be applied to the texture coordinates before sampling.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjLodOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureProjOffset><div></div><div><h2>Name</h2><p>textureProjOffset — perform a texture lookup with projection and offset</div><div><h2>Declaration</h2><div><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec2 <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler1D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler2D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler3D <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec3 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureProjOffset</strong>( sampler1DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> int <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>float <strong>textureProjOffset</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec2 <var>offset</var>,<tr><td> [float <var>bias</var>]);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec3 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>gvec4 <strong>textureProjOffset</strong>( gsampler2DRect <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table><table><tr><td>float <strong>textureProjOffset</strong>( sampler2DRectShadow <var>sampler</var>,<tr><td> vec4 <var>P</var>,<tr><td> ivec2 <var>offset</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture from which texels will be retrieved is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which the texture will be sampled.</p><dt><span> offset </span><dd><p>Specifies the offset that is applied to P before sampling occurs.</p><dt><span> bias </span><dd><p>Specifies an optional bias to be applied during level-of-detail computation.</p></dl></div></div><div><h2>Description</h2><p>textureProjOffset performs a texture lookup with projection. The texture coordinates consumed from P, not including the last component of P, are divided by the last component of P. The resulting <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>3</mml:mn><mml:mi>rd</mml:mi></mml:msup></mml:math> component of P in the shadow forms is used as <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msub><mml:mi>D</mml:mi><mml:mi>ref</mml:mi></mml:msub></mml:math>. After these values are computed, the texture lookup proceeds as in <a href=#textureOffset><span><span>textureOffset</span></span></a>, with the offset used to offset the computed texture coordinates.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureProjOffset<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureProjOffset (gsampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureQueryLevels><div></div><div><h2>Name</h2><p>textureQueryLevels — compute the number of accessible mipmap levels of a texture</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>textureQueryLevels</strong>( gsampler1D <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsampler2D <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsampler3D <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsamplerCube <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsampler1DArray <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsampler2DArray <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( gsamplerCubeArray <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( sampler1DShadow <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( sampler2DShadow <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( samplerCubeShadow <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( sampler1DArrayShadow <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( sampler2DArrayShadow <var>sampler</var>);</table><table><tr><td>int <strong>textureQueryLevels</strong>( samplerCubeArrayShadow <var>sampler</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture whose mipmap level count will be queried is bound.</dt></dl></div></div><div><h2>Description</h2><p>textureQueryLevels returns the number of accessible mipmap levels in the texture associated with sampler.<p>If called on an incomplete texture, or if no texture is associated with sampler, zero is returned.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureQueryLevels<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureQueryLod><div></div><div><h2>Name</h2><p>textureQueryLod — compute the level-of-detail that would be used to sample from a texture</div><div><h2>Declaration</h2><div><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsampler1D <var>sampler</var>,<tr><td> float <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsampler2D <var>sampler</var>,<tr><td> vec2 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsampler3D <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsamplerCube <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsampler1DArray <var>sampler</var>,<tr><td> float <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsampler2DArray <var>sampler</var>,<tr><td> vec2 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( gsamplerCubeArray <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( sampler1DShadow <var>sampler</var>,<tr><td> float <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( sampler2DShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( samplerCubeShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> float <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> vec2 <var>P</var>);</table><table><tr><td>vec2 <strong>textureQueryLod</strong>( samplerCubeArrayShadow <var>sampler</var>,<tr><td> vec3 <var>P</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture whose level-of-detail will be queried is bound.<dt><span> P </span><dd><p>Specifies the texture coordinates at which the level-of-detail will be queried.</p></dl></div></div><div><h2>Description</h2><p><span>Available only in the fragment shader</span>, textureQueryLod computes the level-of-detail that would be used to sample from a texture. The mipmap array(s) that would be accessed is returned in the <span>x</span> component of the return value. The computed level-of-detail relative to the base level is returned in the <span>y</span> component of the return value.<p>If called on an incomplete texture, the result of the operation is undefined.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureQueryLod<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureSamples><div></div><div><h2>Name</h2><p>textureSamples — return the number of samples of a texture</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>textureSamples</strong>( gsampler2DMS <var>sampler</var>);</table><table><tr><td>int <strong>textureSamples</strong>( gsampler2DMSArray <var>sampler</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture is bound.</dt></dl></div></div><div><h2>Description</h2><p>textureSamples returns the number of samples per texel of the texture bound to sampler.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureSamples<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texture><span><span>texture</span></span></a>, <a href=#textureQueryLevels><span><span>textureQueryLevels</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a>, <a href=#textureSize><span><span>textureSize</span></span></a></div></div>
<div id=textureSize><div></div><div><h2>Name</h2><p>textureSize — retrieve the dimensions of a level of a texture</div><div><h2>Declaration</h2><div><table><tr><td>int <strong>textureSize</strong>( gsampler1D <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( gsampler2D <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( gsampler3D <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( gsamplerCube <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>int <strong>textureSize</strong>( sampler1DShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( sampler2DShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( samplerCubeShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( samplerCubeArray <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( samplerCubeArrayShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( gsampler2DRect <var>sampler</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( sampler2DRectShadow <var>sampler</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( gsampler1DArray <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( gsampler2DArray <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( sampler1DArrayShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( sampler2DArrayShadow <var>sampler</var>,<tr><td> int <var>lod</var>);</table><table><tr><td>int <strong>textureSize</strong>( gsamplerBuffer <var>sampler</var>);</table><table><tr><td>ivec2 <strong>textureSize</strong>( gsampler2DMS <var>sampler</var>);</table><table><tr><td>ivec3 <strong>textureSize</strong>( gsampler2DMSArray <var>sampler</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> sampler </span> - Specifies the sampler to which the texture whose dimensions to retrieve is bound.<dt><span> lod </span><dd><p>Specifies the level of the texture for which to retrieve the dimensions.</p></dl></div></div><div><h2>Description</h2><p>textureSize returns the dimensions of level lod (if present) of the texture bound to sampler. The components in the return value are filled in, in order, with the width, height and depth of the texture. For the array forms, the last component of the return value is the number of layers in the texture array.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>textureSize<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureSize (samplerBuffer, sampler2DRect{Shadow})<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>textureSize (samplerCube{Shadow})<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#texelFetch><span><span>texelFetch</span></span></a>, <a href=#texelFetchOffset><span><span>texelFetchOffset</span></span></a>, <a href=#texture><span><span>texture</span></span></a>, <a href=#textureGather><span><span>textureGather</span></span></a>, <a href=#textureGatherOffset><span><span>textureGatherOffset</span></span></a>, <a href=#textureGatherOffsets><span><span>textureGatherOffsets</span></span></a>, <a href=#textureGrad><span><span>textureGrad</span></span></a>, <a href=#textureGradOffset><span><span>textureGradOffset</span></span></a>, <a href=#textureLod><span><span>textureLod</span></span></a>, <a href=#textureLodOffset><span><span>textureLodOffset</span></span></a>, <a href=#textureOffset><span><span>textureOffset</span></span></a>, <a href=#textureProj><span><span>textureProj</span></span></a>, <a href=#textureProjGrad><span><span>textureProjGrad</span></span></a>, <a href=#textureProjGradOffset><span><span>textureProjGradOffset</span></span></a>, <a href=#textureProjLod><span><span>textureProjLod</span></span></a>, <a href=#textureProjLodOffset><span><span>textureProjLodOffset</span></span></a>, <a href=#textureProjOffset><span><span>textureProjOffset</span></span></a>, <a href=#textureQueryLod><span><span>textureQueryLod</span></span></a></div></div>
<div id=transpose><div></div><div><h2>Name</h2><p>transpose — calculate the transpose of a matrix</div><div><h2>Declaration</h2><div><table><tr><td>mat2 <strong>transpose</strong>( mat2 <var>m</var>);</table><table><tr><td>mat3 <strong>transpose</strong>( mat3 <var>m</var>);</table><table><tr><td>mat4 <strong>transpose</strong>( mat4 <var>m</var>);</table><table><tr><td>mat2x3 <strong>transpose</strong>( mat3x2 <var>m</var>);</table><table><tr><td>mat2x4 <strong>transpose</strong>( mat4x2 <var>m</var>);</table><table><tr><td>mat3x2 <strong>transpose</strong>( mat2x3 <var>m</var>);</table><table><tr><td>mat3x4 <strong>transpose</strong>( mat4x3 <var>m</var>);</table><table><tr><td>mat4x2 <strong>transpose</strong>( mat2x4 <var>m</var>);</table><table><tr><td>mat4x3 <strong>transpose</strong>( mat3x4 <var>m</var>);</table><table><tr><td>dmat2 <strong>transpose</strong>( dmat2 <var>m</var>);</table><table><tr><td>dmat3 <strong>transpose</strong>( dmat3 <var>m</var>);</table><table><tr><td>dmat4 <strong>transpose</strong>( dmat4 <var>m</var>);</table><table><tr><td>dmat2x3 <strong>transpose</strong>( dmat3x2 <var>m</var>);</table><table><tr><td>dmat2x4 <strong>transpose</strong>( dmat4x2 <var>m</var>);</table><table><tr><td>dmat3x2 <strong>transpose</strong>( dmat2x3 <var>m</var>);</table><table><tr><td>dmat3x4 <strong>transpose</strong>( dmat4x3 <var>m</var>);</table><table><tr><td>dmat4x2 <strong>transpose</strong>( dmat2x4 <var>m</var>);</table><table><tr><td>dmat4x3 <strong>transpose</strong>( dmat3x4 <var>m</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> m </span> - Specifies the matrix of which to take the transpose.</dt></dl></div></div><div><h2>Description</h2><p>transpose returns the transpose of the matrix m.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>transpose (float)<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>transpose (double)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#determinant><span><span>determinant</span></span></a>, <a href=#inverse><span><span>inverse</span></span></a></div></div>
<div id=trunc><div></div><div><h2>Name</h2><p>trunc — find the truncated value of the parameter</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>trunc</strong>(genType <var>x</var>);</table></div><div><table><tr><td>genDType <strong>trunc</strong>(genDType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specify the value to evaluate.</dt></dl></div></div><div><h2>Description</h2><p>trunc returns a value equal to the nearest integer to x whose absolute value is not larger than the absolute value of x.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>trunc (genType)<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>trunc (genDType)<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floor><span><span>floor</span></span></a>, <a href=#round><span><span>round</span></span></a></div></div>
<div id=uaddCarry><div></div><div><h2>Name</h2><p>uaddCarry — add unsigned integers and generate carry</div><div><h2>Declaration</h2><div><table><tr><td>genUType <strong>uaddCarry</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>,<tr><td> out genUType <var>carry</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the summation operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the summation operation.</p><dt><span> carry </span><dd><p>Specifies the variable to receive the carry output of the sum.</p></dl></div></div><div><h2>Description</h2><p>uaddCarry adds two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a carry output. The result is the sum of x and y modulo <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math>. The value carry is set to 0 if the sum is less than <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math> and to 1 otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>uaddCarry<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#usubBorrow><span><span>usubBorrow</span></span></a></div></div>
<div id=intBitsToFloat><div></div><div><h2>Name</h2><p>intBitsToFloat, uintBitsToFloat — produce a floating point using an encoding supplied as an integer</div><div><h2>Declaration</h2><div><table><tr><td>genType <strong>intBitsToFloat</strong>(genIType <var>x</var>);</table><table><tr><td>genType <strong>uintBitsToFloat</strong>(genUType <var>x</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the bit encoding to return as a floating point value.</dt></dl></div></div><div><h2>Description</h2><p>intBitsToFloat and uintBitsToFloat return the encoding passed in parameter x as a floating-point value. If the encoding of a NaN is passed in x, it will not signal and the resulting value will be undefined. If the encoding of a floating point infinity is passed in parameter x, the resulting floating-point value is the corresponding (positive or negative) floating point infinity.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>intBitsToFloat<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#floatBitsToInt><span><span>floatBitsToInt</span></span></a>, floatBitsToUint, <a href=#isnan><span><span>isnan</span></span></a>, <a href=#isinf><span><span>isinf</span></span></a></div></div>
<div id=umulExtended><div></div><div><h2>Name</h2><p>umulExtended — perform a 32- by 32-bit multiply to produce a 64-bit result</div><div><h2>Declaration</h2><div><table><tr><td>void <strong>umulExtended</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>,<tr><td> out genUType <var>msb</var>,<tr><td> out genUType <var>lsb</var>);</table><table><tr><td>void <strong>imulExtended</strong>(genIType <var>x</var>,<tr><td> genIType <var>y</var>,<tr><td> out genIType <var>msb</var>,<tr><td> out genIType <var>lsb</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first multiplicand.<dt><span> y </span><dd><p>Specifies the second multiplicand.</p><dt><span> msb </span><dd><p>Specifies the variable to receive the most significant word of the product.</p><dt><span> lsb </span><dd><p>Specifies the variable to receive the least significant word of the product.</p></dl></div></div><div><h2>Description</h2><p>umulExtended and imulExtended perform multiplication of the two 32-bit integer quantities x and y, producing a 64-bit integer result. The 32 least significant bits of this product are returned in lsb and the 32 most significant bits are returned in msb. umulExtended and imulExtended perform unsigned and signed multiplication, respectively.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>umulExtended<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#uaddCarry><span><span>uaddCarry</span></span></a></div></div>
<div id=unpackDouble2x32><div></div><div><h2>Name</h2><p>unpackDouble2x32 — produce two unsigned integers containing the bit encoding of a double precision floating point value</div><div><h2>Declaration</h2><div><table><tr><td>uvec2 <strong>unpackDouble2x32</strong>( double <var>d</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> d </span> - Specifies double precision value to break into a pair of unsigned integers.</dt></dl></div></div><div><h2>Description</h2><p>unpackDouble2x32 returns a two-component unsigned integer vector representation of d. The bit-level representation of d is preserved. The first component of the returned vector contains the 32 least significant bits of the double; the second component consists the 32 most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackDouble2x32<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a></div></div>
<div id=unpackHalf2x16><div></div><div><h2>Name</h2><p>unpackHalf2x16 — convert two 16-bit floating-point values packed into a single 32-bit integer into a vector of two 32-bit floating-point quantities</div><div><h2>Declaration</h2><div><table><tr><td>vec2 <strong>unpackHalf2x16</strong>( uint <var>v</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> v </span> - Specify a single 32-bit unsigned integer values that contains two 16-bit floating point values to be unpacked.</dt></dl></div></div><div><h2>Description</h2><p>unpackHalf2x16 returns a two-component floating-point vector with components obtained by unpacking a 32-bit unsigned integer into a pair of 16-bit values, interpreting those values as 16-bit floating-point numbers according to the OpenGL Specification, and converting them to 32-bit floating-point values. The first component of the vector is obtained from the 16 least-significant bits of v; the second component is obtained from the 16 most-significant bits of v.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackHalf2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#packDouble2x32><span><span>packDouble2x32</span></span></a>, <a href=#unpackDouble2x32><span><span>unpackDouble2x32</span></span></a>, <a href=#packHalf2x16><span><span>packHalf2x16</span></span></a></div></div>
<div id=unpackUnorm><div></div><div><h2>Name</h2><p>unpackUnorm2x16, unpackUnorm4x8, unpackSnorm4x8 — unpack floating-point values from an unsigned integer</div><div><h2>Declaration</h2><div><table><tr><td>vec2 <strong>unpackUnorm2x16</strong>( uint <var>p</var>);</table><table><tr><td>vec2 <strong>unpackSnorm2x16</strong>( uint <var>p</var>);</table><table><tr><td>vec4 <strong>unpackUnorm4x8</strong>( uint <var>p</var>);</table><table><tr><td>vec4 <strong>unpackSnorm4x8</strong>( uint <var>p</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> p </span> - Specifies an unsigned integer containing packed floating-point values.</dt></dl></div></div><div><h2>Description</h2><p>unpackUnorm2x16, unpackSnorm2x16, unpackUnorm4x8 and unpackSnorm4x8 unpack single 32-bit unsigned integers, specified in the parameter p into a pair of 16-bit unsigned integers, four 8-bit unsigned integers or four 8-bit signed integers. Then, each component is converted to a normalized floating-point value to generate the returned two- or four-component vector.<p>The conversion for unpacked fixed point value <span>f</span> to floating-point is performed as follows:<div><ul><li><p>packUnorm2x16: f / 65535.0</p><li><p>packSnorm2x16: clamp(f / 32727.0, -1.0, 1.0)</p><li><p>packUnorm4x8: f / 255.0</p><li><p>packSnorm4x8: clamp(f / 127.0, -1.0, 1.0)</p></ul></div><p><p>The first component of the returned vector will be extracted from the least significant bits of the input; the last component will be extracted from the most significant bits.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>unpackUnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>unpackSnorm2x16<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<tr><td>unpackUnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔<tr><td>unpackSnorm4x8<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p>packUnorm2x16, packUnorm4x8, packSnorm4x8</div></div>
<div id=usubBorrow><div></div><div><h2>Name</h2><p>usubBorrow — subtract unsigned integers and generate borrow</div><div><h2>Declaration</h2><div><table><tr><td>genUType <strong>usubBorrow</strong>(genUType <var>x</var>,<tr><td> genUType <var>y</var>,<tr><td> out genUType <var>borrow</var>);</table></div></div><div><h2>Parameters</h2><div><dl><dt><span> x </span> - Specifies the first vector to be used in the subtraction operation.<dt><span> y </span><dd><p>Specifies the second vector to be used in the subtraction operation.</p><dt><span> borrow </span><dd><p>Specifies the variable to receive the borrow output of the difference.</p></dl></div></div><div><h2>Description</h2><p>usubBorrow subtracts two 32-bit unsigned integer variables (scalars or vectors) and generates a 32-bit unsigned integer result, along with a borrow output. The result is the difference of x and y if non-negative, or <mml:math overflow=scroll xmlns:mml=http://www.w3.org/1998/Math/MathML><mml:msup><mml:mn>2</mml:mn><mml:mn>32</mml:mn></mml:msup></mml:math> plus that difference otherwise. The value borrow is set to 0 if x ≥ y and to 1 otherwise.</div><div><h2>Version Support</h2><div><table><colgroup><col><col><col><col><col><col><col><col><col><col><col><col><col></colgroup><thead><tr><th><th colspan=12><span><strong>OpenGL Shading Language Version</strong></span><tr><th><span><strong>Function Name</strong></span><th><span><strong>1.10</strong></span><th><span><strong>1.20</strong></span><th><span><strong>1.30</strong></span><th><span><strong>1.40</strong></span><th><span><strong>1.50</strong></span><th><span><strong>3.30</strong></span><th><span><strong>4.00</strong></span><th><span><strong>4.10</strong></span><th><span><strong>4.20</strong></span><th><span><strong>4.30</strong></span><th><span><strong>4.40</strong></span><th><span><strong>4.50</strong></span><tbody><tr><td>usubBorrow<td>-<td>-<td>-<td>-<td>-<td>-<td>✔<td>✔<td>✔<td>✔<td>✔<td>✔</table></div></div><div><h2>See Also</h2><p><a href=#uaddCarry><span><span>uaddCarry</span></span></a></div></div>
</body>
</html>